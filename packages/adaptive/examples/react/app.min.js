/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./examples/react/hello.jsx":
/*!**********************************!*\
  !*** ./examples/react/hello.jsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function Counter() {
  var _React$useState = React.useState(5),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    count = _React$useState2[0],
    setCount = _React$useState2[1];
  var increment = function increment(e) {
    setCount(count + 1);
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", {
    type: "button",
    onClick: function onClick() {
      increment();
    },
    children: ["clicker React count ", count, ", click me!"]
  });
}
var Button = /*#__PURE__*/function (_React$Component) {
  function Button(props) {
    var _this;
    _classCallCheck(this, Button);
    _this = _callSuper(this, Button, [props]);
    _this.state = {
      count: 1
    };
    _this.increment = _this.increment.bind(_this);
    return _this;
  }
  _inherits(Button, _React$Component);
  return _createClass(Button, [{
    key: "increment",
    value: function increment(e) {
      $adaptive["if"]('tablet', function () {
        console.log('Clicked on Tablet!');
      }).onlyOnce();
      this.setState(function (prevState, props) {
        return {
          count: prevState.count + 1
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", {
        type: "button",
        onClick: this.increment,
        children: ["clicker React count ", this.state.count, ", click me when it Tablet size and watch the console output!"]
      });
    }
  }]);
}(React.Component);
function Hello(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h4", {
      children: "React component"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("p", {
      children: ["This component will move at tablet to static hello ", props.hello]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      "data-adaptive": "addClass.tablet(laura, miau) && addClass.mobile|fullscreen(red, green) &&  addClass.desktop(uno, dos)",
      children: "This is inside the react component"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Counter, {}), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("teleport-to", {
      target: "#hello",
      position: "after",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
        style: {
          padding: '8px',
          background: 'violet'
        },
        children: ["Teleporting an element from inside ", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("b", {
          children: "react"
        }), " component"]
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      "data-adaptive": "teleport.desktop|mobile.before(#hello)",
      style: {
        background: 'beige'
      },
      children: "Teleporting on desktop or mobile"
    })]
  });
}
var root = ReactDOM.createRoot(document.getElementById('reactHello'));
root.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Hello, {
  hello: "component"
}));
var other = ReactDOM.createRoot(document.getElementById('reactButton'));
other.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Button, {}));

/***/ }),

/***/ "../../node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "react");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var displayName = outerType.displayName;

  if (displayName) {
    return displayName;
  }

  var functionName = innerType.displayName || innerType.name || '';
  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber


function getContextName(type) {
  return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


function getComponentNameFromType(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        var outerName = type.displayName || null;

        if (outerName !== null) {
          return outerName;
        }

        return getComponentNameFromType(type.type) || 'Memo';

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentNameFromType(init(payload));
          } catch (x) {
            return null;
          }
        }

      // eslint-disable-next-line no-fallthrough
    }
  }

  return null;
}

var assign = Object.assign;

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if ( !fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                // but we have a user-provided "displayName"
                // splice it in to make the stack more readable.


                if (fn.displayName && _frame.includes('<anonymous>')) {
                  _frame = _frame.replace('<anonymous>', fn.displayName);
                }

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            // eslint-disable-next-line react-internal/prod-error-codes
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */
// $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value) {
  {
    // toStringTag is needed for namespaced types like Temporal.Instant
    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
    return type;
  }
} // $FlowFixMe only called in DEV, so void return is not possible.


function willCoercionThrow(value) {
  {
    try {
      testStringCoercion(value);
      return false;
    } catch (e) {
      return true;
    }
  }
}

function testStringCoercion(value) {
  // If you ended up here by following an exception call stack, here's what's
  // happened: you supplied an object or symbol value to React (as a prop, key,
  // DOM attribute, CSS property, string ref, etc.) and when React tried to
  // coerce it to a string using `'' + value`, an exception was thrown.
  //
  // The most common types that will cause this exception are `Symbol` instances
  // and Temporal objects like `Temporal.Instant`. But any object that has a
  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
  // exception. (Library authors do this to prevent users from using built-in
  // numeric operators like `+` or comparison operators like `>=` because custom
  // methods are needed to perform accurate arithmetic or comparison.)
  //
  // To fix the problem, coerce this object or symbol value to a string before
  // passing it to React. The most reliable way is usually `String(value)`.
  //
  // To find which value is throwing, check the browser or debugger console.
  // Before this exception was thrown, there should be `console.error` output
  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
  // problem and how that type was used: key, atrribute, input value prop, etc.
  // In most cases, this console output also shows the component and its
  // ancestor components where the exception happened.
  //
  // eslint-disable-next-line react-internal/safe-string-coercion
  return '' + value;
}
function checkKeyStringCoercion(value) {
  {
    if (willCoercionThrow(value)) {
      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      {
        checkKeyStringCoercion(maybeKey);
      }

      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */


function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentNameFromType(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentNameFromType(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

var didWarnAboutKeySpread = {};
function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    {
      if (hasOwnProperty.call(props, 'key')) {
        var componentName = getComponentNameFromType(type);
        var keys = Object.keys(props).filter(function (k) {
          return k !== 'key';
        });
        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';

        if (!didWarnAboutKeySpread[componentName + beforeExample]) {
          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';

          error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);

          didWarnAboutKeySpread[componentName + beforeExample] = true;
        }
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, true);
  }
}
function jsxWithValidationDynamic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, false);
  }
}

var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
// for now we can ship identical prod functions

var jsxs =  jsxWithValidationStatic ;

exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsx;
exports.jsxs = jsxs;
  })();
}


/***/ }),

/***/ "../../node_modules/react/jsx-runtime.js":
/*!***********************************************!*\
  !*** ../../node_modules/react/jsx-runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "../../node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ ((module) => {

module.exports = React;

/***/ }),

/***/ "./src/Adaptive.js":
/*!*************************!*\
  !*** ./src/Adaptive.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adaptive: () => (/* binding */ _adaptive),
/* harmony export */   adaptive: () => (/* binding */ _adaptive),
/* harmony export */   "default": () => (/* binding */ _adaptive)
/* harmony export */ });
/* harmony import */ var _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/utility */ "../utility/index.js");
/* harmony import */ var _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/AdaptiveElement.js */ "./src/classes/AdaptiveElement.js");
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryHandler.js */ "./src/QueryHandler.js");
/* harmony import */ var _vue_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vue-components/TeleportTo.js */ "./src/vue-components/TeleportTo.js");
/* harmony import */ var _web_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./web-components/TeleportTo.js */ "./src/web-components/TeleportTo.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [knighttower] https://github.com/knighttower

// Inspired by http://wicky.nillia.ms/enquire.js

// Import the Element DOM helper

// -----------------------------------------








// =========================================
// --> ADAPTIVE JS
// --------------------------

/**
 * @module Adaptive
 * Add/remove classes/styles or teleport an element
 * @return {Object}
 * @example Adaptive(window, Adaptive)
 * @example Adaptive(this, Adaptive)
 * @example Adaptive.registerElement(element)
 * @see "example" folder for more
 */
var _adaptive = function () {
  'use strict';

  _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.domObserver.start();
  var $window = typeof window !== 'undefined' ? window : {};

  // -----------------------------------------
  // This will make it reuse the same instance if already imported without overwrites
  if ($window.$adaptive) {
    return $window.$adaptive;
  }
  // -----------------------------------------

  /**
   * Register this library into the $window
   * @private
   * @return {Object}
   */
  var $this = {
    _mutable: ['registerElement', 'addQueryMinMax', 'addQueryExpression']
  };
  var Adaptive = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.proxyObject)($this);

  /**
   * All the elements that will be part of the grid
   * @private
   */
  var domElements = {};

  /**
   * Flag for isMounted
   * @private
   */
  var isMounted = false;

  /**
   * Flag for using Vue
   * @private
   */
  var useVue = false;

  /**
   * Flag for using React
   * @private
   */
  var useReact = false;

  /**
   * Flag for using React
   * @private
   */
  var useWeb = false;

  /**
   * Flag for using Hybrid
   * @private
   */
  var isHybrid = false;

  /**
   * queries possible sizes
   * @private
   */
  var screens = {
    320: [1, 379],
    480: [380, 519],
    520: [520, 599] /* up to : mobiles */,
    600: [600, 699] /* up to : mid-size-tables */,
    700: [700, 799] /* up to : tablets / ipad */,
    800: [800, 919] /* transition in between tablets and desktop */,
    920: [920, 999] /* from here on for desktops */,
    1000: [1000, 1199],
    1200: [1200, 1439],
    1440: [1440, 1599],
    1600: [1600, 1700]
  };

  /**
   * break the 3 major device types
   * @private
   */
  var devices = {
    mobile: [1, 599] /* Actual phones */,
    tablet: [600, 799] /* tablets in portrait or below */,
    odd: [800, 1023] /* small Laptops and Ipads in landscape */,
    desktop: [1024, 1920] /* Most common resolutions below 1920 */
  };

  /**
   * break the 3 major device types
   * @private
   */
  var broadMediaQueries = {
    'non-desktop': [100, 1023],
    nondesktop: [100, 1023],
    fullscreen: [1920, 6000] /* Large monitos and fullscreen in 1920 res */
  };

  /**
   * To register additional custom queries add the key:[min, max]
   * @private
   */
  var customMinMaxQueries = {};

  /**
   * To register additional custom queries add the key:'Query Expression'
   * @private
   */
  var customExpressionQueries = {};

  // =========================================
  // --> utility
  // --------------------------

  /**
   * Get all the available queries
   * @private
   * @return {Object}
   */
  $this.getAllQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available min max queries
   * @return {Object}
   */
  $this.getMinMaxQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available "expression" queries
   * @return {Object}
   */
  $this.getExpQueries = function () {
    return Object.assign({}, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register an element
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  $this.registerElement = function (elementOrSelector, data) {
    var helper = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(elementOrSelector);
    if (helper.isInDom()) {
      return registerThis(helper, data);
    } else {
      helper.whenInDom().then(function (element) {
        return registerThis(element, data);
      });
    }
  };

  /**
   * Register an element
   * @private
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  function registerThis(element, data) {
    // Register only unique non indexed elements
    if (!element.getAttribute('data-adaptive-id')) {
      var uniqueId = element.getHash();
      var settings = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(data || element.getAttribute('data-adaptive')).directive;

      //set the unique id to the element for later use
      element.domElement.setAttribute('data-adaptive-id', uniqueId);
      domElements[uniqueId] = new _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo(),
        settings: settings,
        useVue: useVue,
        useReact: useReact
      }, $this);
      return uniqueId;
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Min, Max
   * @param {String} id Identifier
   * @param {Number} min Number only, no units attached as it only handles pixels here
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryMinMax = function (id, min, max) {
    if (!customMinMaxQueries[id]) {
      if (!min || !max) {
        throw new Error('Min or Max must be passed (id, min, max)', 1);
      }
      customMinMaxQueries[id] = [min, max];
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} id Identifier
   * @param {String} query Media query, example "screen and (max-width: 500em) and (orientation: landscape)"
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryExpression = function (id, query) {
    if (!customExpressionQueries[id]) {
      customExpressionQueries[id] = query;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} breakdownId Identifier like "tablet" or "mobile", etc
   * @param {Fucntion|Array} callback Function/Method or Array with object and property to set
   * @example Adaptive.if('mobile', [object, propertyId]) || Adaptive.if('mobile', () => {})
   * @return {Object} Proxy
   */
  $this["if"] = function (breakdownId) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var isFunction = callback && typeof callback === 'function';
    var isArray = callback && Array.isArray(callback);
    var observer = {};
    observer[breakdownId] = {
      _private: ['breakdownId', 'match', 'ifElse', 'do', 'removeAfterExec'],
      _mutable: ['ifElse', 'match', 'removeAfterExec'],
      uid: (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDynamicId)(),
      breakdownId: breakdownId,
      match: false,
      executed: false,
      removeAfterExec: false,
      ifElse: null,
      "else": function _else(ifElse) {
        if (ifElse && typeof ifElse === 'function') {
          this.ifElse = ifElse;
        }
      },
      onlyOnce: function onlyOnce() {
        this.removeAfterExec = true;
        if (this.executed) {
          _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
        }
      },
      "do": function _do() {
        if (this.match) {
          if (isFunction) {
            callback();
          }
          if (isArray) {
            callback[0][callback[1]] = true;
          }
          if (this.removeAfterExec) {
            _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
          }
          this.executed = true;
          return true;
        }
        if (isArray) {
          callback[0][callback[1]] = false;
        }
        if (this.ifElse) {
          this.ifElse();
        }
        return false;
      }
    };
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].add(observer, function (o) {
      o.match = true;
      o["do"]();
    }, function (o) {
      o.match = false;
      o["do"]();
    }, $this);
    return (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.proxyObject)(observer[breakdownId]);
  };

  /**
   * Full reset, handle with care
   * @private
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(domElements).forEach(function (key) {
      return delete domElements[key];
    });
    _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.domObserver.cleanup();
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset();
    isMounted = false;
  };

  // =========================================
  // --> DomReady and INIT
  // --------------------------

  /**
   * Real init for the app
   * @private
   */
  function _init() {
    isMounted = true;
    document.querySelectorAll('[data-adaptive]:not([data-adaptive-id])').forEach(function (element) {
      $this.registerElement(element);
    });
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].init();
    if (useVue || useReact) {
      // hybrid mode
      // support for static and dynamic elements
      if (isHybrid) {
        (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
      }
    } else {
      // vanilla js
      (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Initialization, cam be called externally to reinitialized after dom loaded
   * @return {Void}
   */
  $this.init = function () {
    if (isMounted) {
      return false;
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
      return domIsReady();
    } else {
      // Use the handy event callback
      document.addEventListener('DOMContentLoaded', domIsReady);
      // A fallback to $window.onload, that will always work
      $window.addEventListener('load', domIsReady);
    }
    return;
  };

  /**
   * When ready trigger the initialization
   * @private
   */
  function domIsReady() {
    document.removeEventListener('DOMContentLoaded', domIsReady);
    $window.removeEventListener('load', domIsReady);
    _init();
    return;
  }

  /**
   * @memberof Adaptive
   * @inner
   * For use with Vue
   * @param {Vue} Vue Vue instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Vue}
   */
  $this.useVue = function (Vue) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(Vue) === 'object' && typeof Vue.mixin === 'function') {
      useVue = true;
      var installer = {
        install: function install(app) {
          // For Options API
          app.config.globalProperties.Adaptive = Adaptive;
          // For composition API
          app.provide('Adaptive', Adaptive);
        }
      };

      /**
       * Adaptive used as vue.$Adaptive
       * @private
       */
      Vue.use(installer);
      /**
       * Adaptive used as v-adaptive
       * @private
       */
      Vue.directive('adaptive', {
        mounted: function mounted(element, binding) {
          Adaptive.registerElement(element, binding.value);
        }
      });

      /**
       * Adaptive used as v-teleport-to
       * @private
       */
      Vue.directive('teleport-to', {
        mounted: function mounted(element, binding) {
          return new _Teleport_js__WEBPACK_IMPORTED_MODULE_2__.Teleport(element).beam(binding.value);
        }
      });
      Vue.component('TeleportTo', _vue_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

      /**
       * Adaptive used for non Vue elements register with data-adaptive attr
       * Hybrid mode
       * @private
       */
      Vue.mixin({
        mounted: function mounted() {
          return Adaptive.init();
        }
      });
    }
    return Vue;
  };

  //docs
  /**
   * For use with Web Components
   * @private
   * @return {Void}
   */
  $this.useWebComponent = function () {
    if (!useWeb && !useVue) {
      (0,_web_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_5__["default"])();
      useWeb = true;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * For use with React
   * @param {React} React React instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Void}
   */
  $this.useReact = function (React) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(React) === 'object') {
      $this.useWebComponent();
      useReact = true;
    }
  };
  $window.$adaptive = Adaptive;
  return $window.$adaptive;
}();


/***/ }),

/***/ "./src/QueryHandler.js":
/*!*****************************!*\
  !*** ./src/QueryHandler.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QueryHandler: () => (/* binding */ QH),
/* harmony export */   "default": () => (/* binding */ QH),
/* harmony export */   queryHandler: () => (/* binding */ QH)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _readOnlyError(name) { throw new TypeError("\"" + name + "\" is read-only"); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower

/**
 * @class CSS Query Handler
 * @return QueryHandler
 */
var QH = function QueryHandler() {
  'use strict';
  var $window = typeof window !== 'undefined' ? window : {};
  /**
   * Query Handler Class Object
   * @private
   * @return {Object}
   */
  var $this = {};
  var QueryHandler = new Proxy($this, {
    get: function get(target, prop) {
      if (prop in target) {
        return target[prop];
      }
    }
  });

  /**
   * Holds memory of registered queries expressions
   * @private
   */
  var registeredQueries = {};

  /**
   * Holds memory of registered queries to match
   * @private
   */
  var domQueriesMatch = {};

  /**
   * Holds memory of registered queries to Unmatch
   * @private
   */
  var domQueriesUnMatch = {};

  /**
   * Flag
   * @private
   */
  var loaded = false;

  // =========================================
  // --> PUBLIC
  // --------------------------

  /**
   * Register a query
   * @param {Object} queries Media queries with breakdowns and directives
   * @param {Function} matchCallback Callback
   * @param {Function|Null} unMatchCallback Callback
   * @param {Object|Null} Adaptive When in use with Adaptive.js object
   * @return {Void}
   */
  $this.add = function (queries, matchCallback) {
    var unMatchCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var Adaptive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    for (var query in queries) {
      var _getPreset;
      // Values are the classes, styles, functions
      var values = queries[query];

      // Set a preset if found or just the query in case is custom
      var queryExpression = (_getPreset = getPreset(query, Adaptive)) !== null && _getPreset !== void 0 ? _getPreset : query;

      // If it does not exists, add it as an array
      if (!domQueriesMatch[queryExpression]) {
        domQueriesMatch[queryExpression] = [];
        domQueriesUnMatch[queryExpression] = [];
      }
      domQueriesMatch[queryExpression].push([matchCallback, values]);
      if (unMatchCallback) {
        domQueriesUnMatch[queryExpression].push([unMatchCallback, values]);
      }
      registerQueryListener(queryExpression);
    }
  };

  /**
   * Remove items from domQueriesMatch based on value and prop.
   *
   * @param {any} value - The value to be removed.
   * @param {string} prop - The property to look up in the object.
   */
  $this.remove = function (value, prop) {
    for (var _i = 0, _Object$entries = Object.entries(domQueriesMatch); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        expression = _Object$entries$_i[0],
        collection = _Object$entries$_i[1];
      var _iterator = _createForOfIteratorHelper(collection),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var reg = _step.value;
          var type = _typeof(reg[1]);
          // LookUp by the prop value when the second array element is an object
          if (prop && type === 'object') {
            if (prop in reg[1] && reg[1][prop] === value) {
              console.log(domQueriesMatch[expression]);
              domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
                return o[1][prop] !== value;
              });
            }
            // LookUp by the value (function) and prop when the second array element is a string
          } else if (type === 'string' && reg[1] === prop) {
            domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
              return o[0] !== value;
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };

  /**
   * Initialization of the class functionality
   * @return {Void}
   */
  $this.init = function () {
    loaded = true;
    Object.keys(domQueriesMatch).forEach(function (queryExpression) {
      // Listener for after initial load
      registerQueryListener(queryExpression);
      // Run the queries on load once
      singleRun(queryExpression);
    });
  };

  /**
   * Reset the whole object | warning
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(registeredQueries).forEach(function (queryExpression) {
      $window.matchMedia(queryExpression).removeEventListener('change', registeredQueries[queryExpression]);
      delete registeredQueries[queryExpression];
    });
    Object.keys(domQueriesMatch).forEach(function (key) {
      return delete domQueriesMatch[key];
    });
    Object.keys(domQueriesUnMatch).forEach(function (key) {
      return delete domQueriesUnMatch[key];
    });
  };

  // =========================================
  // --> PRIVATE
  // --------------------------

  function singleRun(queryExpression) {
    var mq = $window.matchMedia(queryExpression);
    if (mq.matches) {
      domQueriesMatch[mq.media].forEach(function (callback) {
        return callback[0](callback[1]);
      });
    }
  }

  /**
   * Get the preset query values present in Adaptive object
   * @private
   */
  function getPreset(queryId) {
    var Adaptive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var presets = {
      q: null,
      // query min-max values preset
      e: null // custom expression preset
    };

    // -----------------------------------------
    // when working with Adaptive.Js
    if (Adaptive) {
      var _presetQs$queryId, _presetEs$queryId;
      var presetQs = Adaptive.getMinMaxQueries();
      var presetEs = Adaptive.getExpQueries();
      presets.q = (_presetQs$queryId = presetQs[queryId]) !== null && _presetQs$queryId !== void 0 ? _presetQs$queryId : null;
      presets.e = (_presetEs$queryId = presetEs[queryId]) !== null && _presetEs$queryId !== void 0 ? _presetEs$queryId : null;
      if (!presets.q && !presets.e) {
        if (queryId.includes('|')) {
          var qs = queryId.split('|');
          var qs1 = qs[0];
          var qs2 = qs[1];
          if (presetQs[qs1] && presetQs[qs2]) {
            return buildExpression(presetQs[qs1], presetQs[qs2], true);
          }
          if (presetEs[qs1] && presetEs[qs2]) {
            return buildExpression(presetEs[qs1], presetEs[qs2], true, true);
          }
        }
      } else {
        // Write the correct expression for the preset min-max
        if (presets.q) {
          return buildExpression(presets.q[0], presets.q[1]);
        }
        // No need to build the expression as it already is
        if (presets.e) {
          return presets.e;
        }
      }
    }
    return null;
  }

  /**
   * @private
   */
  function buildExpression(q1, q2) {
    var isCompound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isExpression = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var templateQuery = '(min-width: $1px) and (max-width: $2px)';
    if (isCompound) {
      if (!isExpression) {
        q1 = templateQuery.replace('$1', q1[0]).replace('$2', q1[1]);
        q2 = templateQuery.replace('$1', q2[0]).replace('$2', q2[1]);
      }
      return "".concat(q1, ", ").concat(q2);
    }
    return templateQuery.replace('$1', q1).replace('$2', q2);
  }
  function registerQueryListener(queryExpression) {
    // If not already registered
    // This helps to avoid too many Listeners created
    if (!registeredQueries[queryExpression]) {
      var matchQuery = $window.matchMedia(queryExpression);
      var callback = function callback(mq) {
        if (!mq.matches) {
          domQueriesUnMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        } else {
          domQueriesMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        }
      };
      registeredQueries[queryExpression] = callback;
      return matchQuery.addEventListener('change', callback);
    }
    // For those added after the loaded event
    if (loaded) {
      singleRun(queryExpression);
    }
  }
  $window.QueryHandler = QueryHandler;
  return $window.QueryHandler;
}();


/***/ }),

/***/ "./src/Teleport.js":
/*!*************************!*\
  !*** ./src/Teleport.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   TeleportGlobal: () => (/* binding */ TeleportGlobal),
/* harmony export */   "default": () => (/* binding */ Teleport),
/* harmony export */   teleport: () => (/* binding */ Teleport)
/* harmony export */ });
/* harmony import */ var _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/utility */ "../utility/index.js");
/* harmony import */ var _knighttower_type_check__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @knighttower/type-check */ "../type-check/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower



/**
 * @module Teleport
 * Teleport an element to another place in the DOM before, inside or after a target
 * @param {Object|String} props || selector - props object (domElement: element, adaptiveId: null|uniqueId})
 * @example new Teleport({domElement: element, adaptiveId: uniqueId}).beam({to: selector})
 * @example new Teleport(domElement).beam({after: selector})
 * @example new Teleport(domElement).beam({before: selector})
 * @example new Teleport(domElement).beam(selector) // defaults to "to" which is inside the selector
 * @example const eleTeleport = new Teleport(domElement) // returns the object with eleTeleport{beam(String|Object), back(), cancel()}
 * @example Make it global so that is available in the browser and works as a 'window' library
 *   TeleportGlobal()
 *      - <div data-teleport="selector"></div>
 *      - <div data-teleport="{before: 'selector'}"></div>
 *     - <div data-teleport="{after: 'selector'}"></div>
 * @feature If the target (element where it will be sent to) is not in the DOM it will wait until it is and then it will beam the element
 * @return {Object} Teleport object
 */
var Teleport = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector || props object (see AdaptiveElement)
   * @return {Object}
   */
  function Teleport(props) {
    _classCallCheck(this, Teleport);
    _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.domObserver.start();
    // Early exit if no props are provided
    if (!(0,_knighttower_type_check__WEBPACK_IMPORTED_MODULE_1__.validType)(props, 'string|object')) {
      return;
    }
    this.props = props;
    if (!this.props.adaptiveId) {
      var _element$getAttribute;
      var element = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(this.props);
      var attrId = (_element$getAttribute = element.getAttribute('data-adaptive-id')) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : null;
      // If adaptiveId is not present, create or retrieve it
      var uniqueId = attrId || element.getHash();
      if (!attrId) {
        element.domElement.setAttribute('data-adaptive-id', uniqueId);
      }

      // Update props with additional properties
      this.props = Object.assign({}, this.props, {
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo()
      });
    }
    var placeholder = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
    if (!placeholder.isInDom()) {
      placeholder = document.createElement('param');
      placeholder.name = 'adaptive';
      placeholder.value = this.props.adaptiveId;
      this.props.domElement.insertAdjacentElement('beforebegin', placeholder);
    }
  }

  /**
   * Beam the element to another place in the DOM
   * This method will look for the "tagert" element if it is in the DOM and it will querying the DOM until it finds it
   * if the target is not found call the cancel() method to stop the observer
   * @param {String|Object} target (selector) directive defaults to "to" || {to|after|before: target}
   * @example new Teleport(domElement).beam({after: selector})
   * @example domElement.beam({after: selector})
   */
  return _createClass(Teleport, [{
    key: "beam",
    value: function beam(settings) {
      var _this = this;
      settings = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(settings).directive;

      // Transform settings to an array format
      switch ((0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(settings)) {
        case 'string':
          settings = ['default', settings];
          break;
        case 'object':
          // eslint-disable-next-line no-case-declarations
          var key = Object.keys(settings)[0];
          settings = [key, settings[key]];
          break;
        case 'array':
          if (settings.length === 1) {
            settings = ['default', settings[0]];
          }
          break;
      }
      var _settings = settings,
        _settings2 = _slicedToArray(_settings, 2),
        direction = _settings2[0],
        selector = _settings2[1];
      var target = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
      var position = 'beforeend';
      switch (direction) {
        case 'before':
          position = 'beforebegin';
          break;
        case 'after':
          position = 'afterend';
          break;
      }
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement(position, this.props.domElement);
        return;
      }

      // Add observer if the target is not in the DOM
      _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.domObserver.addOnNodeChange(this.props.adaptiveId, function () {
        var observedTarget = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
        if (observedTarget.isInDom()) {
          observedTarget.domElement.insertAdjacentElement(position, _this.props.domElement);
          _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.domObserver.removeOnNodeChange(_this.props.adaptiveId);
        }
      });
    }

    /**
     * Return to its original place
     * @example new Teleport(domElement).back()
     * @example domElement.back()
     */
  }, {
    key: "back",
    value: function back() {
      var target = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement('afterend', this.props.domElement);
        // target.domElement.remove();
      }
    }

    /**
     * If element target is no it the DOM and needs to cancel the observer
     * @example new Teleport(domElement).cancel()
     * @example domElement.cancel()
     */
  }, {
    key: "cancel",
    value: function cancel() {
      _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.domObserver.removeOnNodeChange(this.props.adaptiveId);
    }
  }]);
}(); // Storage
var TeleportIsGlobal = false;

/**
 * Warning, this will make it global and would work with data attr like data-teleport
 * @example new Teleport().global()
 */
function TeleportGlobal() {
  // Exit if already initialized
  if (TeleportIsGlobal) {
    return;
  }

  // Use forEach directly on NodeList
  document.querySelectorAll('[data-teleport]').forEach(function (element) {
    new Teleport(element).beam(element.getAttribute('data-teleport'));
  });

  // Mark as initialized
  TeleportIsGlobal = true;
}


/***/ }),

/***/ "./src/classes/AdaptiveElement.js":
/*!****************************************!*\
  !*** ./src/classes/AdaptiveElement.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdaptiveElement)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../QueryHandler.js */ "./src/QueryHandler.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// when it imports, it also registers itself as global


/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {Object} props
 * @param {Object} Adaptive Instance of
 * @return {Object}
 */
var AdaptiveElement = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector
   * @return {Object}
   */
  function AdaptiveElement(props, Adaptive) {
    var _this = this;
    _classCallCheck(this, AdaptiveElement);
    _defineProperty(this, "_addClass", function ($classes) {
      $classes = $classes.split(' ');
      $classes.forEach(function ($class) {
        _this.props.domElement.classList.add($class);
      });
      return;
    });
    _defineProperty(this, "_removeClass", function ($classes) {
      $classes = $classes.split(' ');
      $classes.forEach(function ($class) {
        _this.props.domElement.classList.remove($class);
      });
      return;
    });
    this.props = props;
    this.Adaptive = Adaptive;
    for (var directive in props.settings) {
      // Matches the method name and passes the directives
      this[directive](props.settings[directive]);
    }
  }
  return _createClass(AdaptiveElement, [{
    key: "addClass",
    value: function addClass(queries) {
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, this._addClass, this._removeClass, this.Adaptive);
    }
  }, {
    key: "removeClass",
    value: function removeClass(queries) {
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, this._removeClass, this._addClass, this.Adaptive);
    }
  }, {
    key: "addStyle",
    value: function addStyle(queries) {
      var _this2 = this;
      // Save the original style in memory to not discard them
      this.props.originalStyle = this.props.domElement.getAttribute('style');
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($styles) {
        // eslint-disable-next-line no-return-assign
        return _this2.props.domElement.style.cssText += $styles;
      }, function () {
        // eslint-disable-next-line no-return-assign
        return _this2.props.domElement.style.cssText = _this2.props.originalStyle;
      }, this.Adaptive);
    }
  }, {
    key: "teleport",
    value: function teleport(queries) {
      var $element = new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.props);
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($directive) {
        return $element.beam($directive);
      }, function () {
        $element.back();
        return $element.cancel();
      }, this.Adaptive);
    }
  }, {
    key: "execute",
    value: function execute(queries) {
      var $element = this;
      var attrs = {
        adaptiveId: $element.props.uniqueId,
        helper: $element.props.helper,
        domElement: $element.props.domElement,
        xpath: $element.props.xpath
      };
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, this.Adaptive);
    }
  }]);
}();


/***/ }),

/***/ "./src/vue-components/TeleportTo.js":
/*!******************************************!*\
  !*** ./src/vue-components/TeleportTo.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Adaptive Teleport
 * @module
 * @example <teleport-to target="" position=""></teleport-to>
 * @property {String|Object} target
 * @property {String} target
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'TeleportTo',
  inheritAttrs: false,
  props: {
    target: {
      type: [String, Object],
      require: true
    },
    position: {
      type: String,
      "default": 'to',
      require: false
    }
  },
  setup: function setup(props) {
    var directive = "".concat(props.position, "(").concat(props.target, ")");
    return {
      directive: directive
    };
  },
  template: "\n        <div>\n            <div v-teleport-to=\"directive\">\n                <slot></slot>\n            </div>\n        </div>\n    "
});

/***/ }),

/***/ "./src/web-components/TeleportTo.js":
/*!******************************************!*\
  !*** ./src/web-components/TeleportTo.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ componentTeleportTo)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TeleportTo = /*#__PURE__*/function (_HTMLElement) {
  function TeleportTo() {
    _classCallCheck(this, TeleportTo);
    return _callSuper(this, TeleportTo);
  }
  _inherits(TeleportTo, _HTMLElement);
  return _createClass(TeleportTo, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      var _this$getAttribute;
      var target = this.getAttribute('target');
      var position = (_this$getAttribute = this.getAttribute('position')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : 'to';
      var dId = this.getAttribute('data-adaptive-id');
      if (target && !dId) {
        return new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this).beam("".concat(position, "(").concat(target, ")"));
      }
    }
  }]);
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
function componentTeleportTo() {
  customElements.define('teleport-to', TeleportTo);
}

/***/ }),

/***/ "../type-check/index.js":
/*!******************************!*\
  !*** ../type-check/index.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__.TypeCheck),
/* harmony export */   _tc: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__._tc),
/* harmony export */   _tcx: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__._tcx),
/* harmony export */   _typeCheck: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__._typeCheck),
/* harmony export */   addTypeTest: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__.addTypeTest),
/* harmony export */   typeCheck: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   typesMap: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__.typesMap),
/* harmony export */   validType: () => (/* reexport safe */ _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__.validType)
/* harmony export */ });
/* harmony import */ var _src_typeCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/typeCheck.js */ "../type-check/src/typeCheck.js");
// Single Modules and Aliases from: typeCheck

// Default Module from: typeCheck



/***/ }),

/***/ "../type-check/src/testBuilder.js":
/*!****************************************!*\
  !*** ../type-check/src/testBuilder.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addTypeTest: () => (/* binding */ addTypeTest),
/* harmony export */   "default": () => (/* binding */ testBuilder),
/* harmony export */   testBuilder: () => (/* binding */ testBuilder),
/* harmony export */   typesMap: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "../type-check/src/types.js");
/* harmony import */ var _knighttower_utility__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @knighttower/utility */ "../utility/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//  type definitions


'use strict';

// =========================================
// --> STORAGE
// --------------------------
// Cache storage for tests
var cachedTests = new Map();
var cachedPipedTypes = new Map();

// =========================================
// --> Utility functions
// --------------------------

/**
 * If the type is a union type, split it and return the tests for each type
 * @param {string} str
 * @return {array} tests
 */
function getPipedTypes(str) {
  if (cachedPipedTypes.has(str)) {
    return cachedPipedTypes.get(str);
  }
  return str.split('|').reduce(function (testsForKey, t) {
    var itCanBeNull = false;
    var type = t.trim();
    if (type.endsWith('?')) {
      type = type.slice(0, -1);
      itCanBeNull = true;
    }
    // lookup the test for the type and add it to the testsForKey array
    var typeObj = _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.get(type);
    var test = typeObj !== null && typeObj !== void 0 ? typeObj : isNoType(type);
    if (test) {
      testsForKey.push(test);
    }
    // for optional types, add the tests for null and undefined
    if (itCanBeNull) {
      testsForKey.push(_types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.get('null'), _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.get('undefined'));
    }
    cachedPipedTypes.set(str, testsForKey);
    return testsForKey;
  }, []);
}

/**
 * Get the tests for a type
 * @param {string} type
 * @return {function[]} tests
 * @throws {Error} if type is not supported
 */
function isNoType(type) {
  throw new Error("Type Error: \"".concat(type, "\" is not supported"));
}

/**
 * Determine the type of the expression
 * @param {any} strExp
 * @return {string}
 */
function determineMethod(strExp) {
  if ((0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.typeOf)(strExp, 'array') || (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.typeOf)(strExp, 'object')) {
    return (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.typeOf)(strExp);
  }
  var __str = strExp.trim();
  if ((0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.startAndEndWith)(__str, '[', ']')) {
    return 'array';
  }
  if ((0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.startAndEndWith)(__str, '{', '}')) {
    return 'object';
  }
  return 'basic';
}

// =========================================
// --> Handlers for different types
// --------------------------

/**
 * Basic single types
 * @param {string} typeStr
 * @return {object} tests
 */
var basicTypes = function basicTypes(typeStr) {
  return getPipedTypes(typeStr);
};

/**
 * Handle array types
 * @param {string} strExp
 * @return {array} tests
 */
var arrayTypes = function arrayTypes(strExp) {
  var testUnit = [];
  var convertedObj = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.getArrObjFromString)(strExp);
  convertedObj.forEach(function (test) {
    testUnit.push(testBuilder(test));
  });
  return testUnit;
};

/**
 * Handle object types
 * @param {string} strExp
 * @return {object} tests
 */
var objectTypes = function objectTypes(strExp) {
  return new ( /*#__PURE__*/function () {
    function handleObjects() {
      _classCallCheck(this, handleObjects);
      this.testUnit = new Map([['tests', new Map()], ['optionalKeys', []], ['testFew', []], ['testAllAny', false], ['testOnly', false]]);
      return this.handleObject();
    }
    return _createClass(handleObjects, [{
      key: "checkOptionalKey",
      value: function checkOptionalKey(key) {
        if (key.endsWith('?')) {
          key = key.slice(0, -1);
          this.testUnit.get('optionalKeys').push(key);
        }
        return key;
      }
    }, {
      key: "checkTheAnyKey",
      value: function checkTheAnyKey(obj) {
        if ('any' in obj) {
          var keys = Object.keys(obj);
          if (keys.length === 1) {
            this.testUnit.set('testAllAny', true);
          } else {
            this.testUnit.set('testFew', keys.filter(function (key) {
              return key !== 'any';
            }));
          }
        }
      }
    }, {
      key: "handleObject",
      value: function handleObject() {
        var convertedObj = (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_1__.getArrObjFromString)(strExp);
        this.checkTheAnyKey(convertedObj);
        for (var key in convertedObj) {
          var cleanKey = this.checkOptionalKey(key);
          var value = convertedObj[key];
          if (value === '...') {
            delete convertedObj[key];
            this.testUnit.set('testOnly', true);
            continue;
          }
          this.testUnit.get('tests').set(cleanKey, testBuilder(value));
        }
        return this.testUnit;
      }
    }]);
  }())();
};

/**
 * Build the test unit
 * @param {any} strExp String expression
 * @return {object} testUnit
 * @throws {Error} if type is not supported
 * @example testBuilder('number') // returns {testMethod: 'basic', tests: [function]}
 * @example testBuilder('[number]') // returns {testMethod: 'array', tests: [[function]]}
 * @example testBuilder('{any: number}') // returns {testMethod: 'object', tests: {any: [function]}}
 * @usage See more cases in the 'type-pattern.txt' file
 */
function testBuilder(strExp) {
  if (cachedTests.has(strExp)) {
    return cachedTests.get(strExp);
  }
  var testUnit = new Map([['testMethod', determineMethod(strExp)], ['tests', null]]);
  switch (testUnit.get('testMethod')) {
    case 'basic':
      testUnit.set('tests', basicTypes(strExp));
      break;
    case 'array':
      testUnit.set('tests', arrayTypes(strExp));
      break;
    case 'object':
      /* eslint-disable-next-line */
      var objTypes = objectTypes(strExp);
      testUnit = new Map([].concat(_toConsumableArray(testUnit), _toConsumableArray(objTypes)));
      break;
    default:
      isNoType(strExp);
  }
  cachedTests.set(strExp, testUnit);
  return testUnit;
}

/**
 * Add a new type test
 * @param {string} name The name of the test to add
 * @param {function} testUnit The test function
 * @return {boolean} true if the test was added
 * @throws {Error} if the test already exists
 */
var addTypeTest = function addTypeTest(name, testUnit) {
  if (!_types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.has(name)) {
    _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.set(name, testUnit);
    return true;
  }
  return "\"".concat(name, "\" already exists!");
};


/***/ }),

/***/ "../type-check/src/typeCheck.js":
/*!**************************************!*\
  !*** ../type-check/src/typeCheck.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* binding */ typeCheck),
/* harmony export */   _tc: () => (/* binding */ _tc),
/* harmony export */   _tcx: () => (/* binding */ _tcx),
/* harmony export */   _typeCheck: () => (/* binding */ _typeCheck),
/* harmony export */   addTypeTest: () => (/* reexport safe */ _testBuilder_js__WEBPACK_IMPORTED_MODULE_1__.addTypeTest),
/* harmony export */   "default": () => (/* binding */ typeCheck),
/* harmony export */   typeCheck: () => (/* binding */ typeCheck),
/* harmony export */   typesMap: () => (/* reexport safe */ _testBuilder_js__WEBPACK_IMPORTED_MODULE_1__.typesMap),
/* harmony export */   validType: () => (/* binding */ validType)
/* harmony export */ });
/* harmony import */ var _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/utility */ "../utility/index.js");
/* harmony import */ var _testBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./testBuilder.js */ "../type-check/src/testBuilder.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



// Error collectot
var typeErrorLogs = [];
// Setting cache
var cachedSettings = new Map();
var runBasicTest = function runBasicTest(inputVal, tests) {
  return tests.some(function (test) {
    var testResult = test(inputVal);
    if (!testResult) {
      pushToErrorLogs(inputVal, tests);
    }
    return testResult;
  });
};
var runArrayTest = function runArrayTest(inputVal, tests) {
  // If the input is not an array, return false
  if (!(0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(inputVal, 'array') || inputVal.length === 0) {
    return false;
  }
  // Else, test each value in the array
  return tests.every(function (test, index) {
    // console.log('is array: ', inputVal[index], test);
    return runRouteTest(inputVal[index], test);
  });
};
var HandleObjects = /*#__PURE__*/function () {
  function HandleObjects(inputVal, unitTest) {
    _classCallCheck(this, HandleObjects);
    // Extract all properties at once
    var _reduce = _toConsumableArray(unitTest.entries()).reduce(function (acc, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, value));
      }, {}),
      testOnly = _reduce.testOnly,
      testFew = _reduce.testFew,
      testAllAny = _reduce.testAllAny,
      optionalKeys = _reduce.optionalKeys,
      tests = _reduce.tests;
    // Use destructured variables
    this.testUnitKeys = _toConsumableArray(tests.keys());
    this.testOnly = testOnly;
    this.testFew = testFew;
    this.testAllAny = testAllAny;
    this.optionalKeys = optionalKeys;
    this.testCollection = tests;
    // the input object to test
    this.inputObject = inputVal;
  }
  return _createClass(HandleObjects, [{
    key: "handleUnitTest",
    value: function handleUnitTest() {
      switch (true) {
        case this.testAllAny:
          // '{any: type}' // any key
          return this.testObjAllAny();
        case !(0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.testFew):
          // '{key1: type, any: type}'; // specific key, and all other "any"
          // test the testFew fist so that we can remove them from the inputObject
          /* eslint-disable-next-line */
          var testFewResults = this.testObjFew();
          // remove the testFew from the inputObject
          this.filterOutFew();
          return testFewResults && this.testObjAllAny();
        case !(0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.optionalKeys):
          // '{key1?: type, key2?: type}'; // optional keys
          // test the optionalKeys fist so that we can remove them from the inputObject
          /* eslint-disable-next-line */
          var optionalKeysResults = this.testObjOptionalKeys();
          // remove the optionalKeys from the inputObject
          this.filterOutOptionalKeys();
          return optionalKeysResults && this.defaultTest();
        case !this.testOnly:
          // '{key1: type, key2: type}'; // all keys
          for (var k in this.inputObject) {
            if (!this.testCollection.has(k)) {
              pushToErrorLogs(this.inputObject, "Key: \"".concat(k, "\" not found in the test collection, or use the \"any\" (any:[type]) key test or \"...\" after the last key in the test collection {key1: type, key2: type, ...} to only test a few keys."));
              return false;
            }
          }
          // when testOnly, it will bypass this and check only those found in the test collection
          // even if the test value has more keys
          break;
      }
      return this.defaultTest();
    }
  }, {
    key: "filterOutOptionalKeys",
    value: function filterOutOptionalKeys() {
      var _this = this;
      this.testUnitKeys = this.testUnitKeys.filter(function (item) {
        return !_this.optionalKeys.includes(item);
      });
    }
  }, {
    key: "filterOutFew",
    value: function filterOutFew() {
      var _this2 = this;
      this.inputObject = Object.fromEntries(Object.entries(this.inputObject).filter(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 1),
          key = _ref4[0];
        return !_this2.testFew.includes(key);
      }));
    }
  }, {
    key: "testObjOptionalKeys",
    value: function testObjOptionalKeys() {
      var _this3 = this;
      return this.optionalKeys.every(function (key) {
        var test = _this3.testCollection.get(key);
        var testValue = _this3.inputObject[key];
        return !testValue ? true : runRouteTest(testValue, test);
      });
    }
  }, {
    key: "testObjFew",
    value: function testObjFew() {
      var _this4 = this;
      return this.testFew.every(function (key) {
        var test = _this4.testCollection.get(key);
        var testValue = _this4.inputObject[key];
        return runRouteTest(testValue, test);
      });
    }
  }, {
    key: "testObjAllAny",
    value: function testObjAllAny() {
      var _this5 = this;
      var testValues = Object.values(this.inputObject);
      if (testValues.length === 0) {
        return runRouteTest(null, this.testCollection.get('any'));
      }
      return testValues.every(function (value) {
        return runRouteTest(value, _this5.testCollection.get('any'));
      });
    }
  }, {
    key: "defaultTest",
    value: function defaultTest() {
      var _this6 = this;
      return this.testUnitKeys.every(function (key) {
        var test = _this6.testCollection.get(key);
        var testValue = _this6.inputObject[key];
        return runRouteTest(testValue, test);
      });
    }
  }]);
}();
var runObjectTest = function runObjectTest(inputVal, unitTest) {
  if (!(0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(inputVal, 'object')) {
    return false;
  }
  return new HandleObjects(inputVal, unitTest).handleUnitTest();
};
function runRouteTest(inputVal, unitTest) {
  var testMethod = unitTest.get('testMethod');
  var tests = unitTest.get('tests');
  switch (testMethod) {
    case 'basic':
      return runBasicTest(inputVal, tests);
    case 'array':
      return runArrayTest(inputVal, tests);
    case 'object':
      return runObjectTest(inputVal, unitTest);
    // No change here as the entire Map is passed
    default:
      return false;
  }
}

/**
 * Get settings either from an object or a string keyword.
 * @param {Object | string} input - The settings object or keyword for predefined settings.
 * @return {object | null} - The settings object.
 */
function getSettings(input) {
  if (input) {
    if (cachedSettings.has(input)) {
      return cachedSettings.get(input);
    }
    // Check if input is an object
    var type = _typeof(input);
    var _val = null;
    switch (type) {
      case 'function':
        _val = {
          callback: input
        };
        break;
      case 'object':
        _val = input;
        break;
      case 'string':
        switch (input) {
          case 'log':
            _val = {
              log: true
            };
            break;
          case 'fail':
            _val = {
              fail: true
            };
            break;
          case 'return':
            _val = {
              "return": true
            };
            break;
          case 'validOutput':
            _val = {
              validOutput: input
            };
            break;
        }
        break;
    }
    cachedSettings.set(input, _val);
    return _val;
  }
  return {
    log: false,
    fail: false,
    "return": false,
    validOutput: false,
    callback: null
  };
}

/**
 * Throw an error with the last typeErrorLogs
 */
function typeError(inputVal) {
  var errorLog = typeErrorLogs[typeErrorLogs.length - 1];
  console.log('\n::::::::::::: Type error or not valid ::::::::::::::');
  console.log('Input Value used: ', inputVal);
  console.log('---> Value Found:', errorLog.found);
  console.log('---> Test Permormed:', errorLog.tests);
  //clean the array of error logs
  typeErrorLogs.length = 0;
  throw new Error("\n\n---------------------\nTypeCheck Error --->\n\n The value must not be of type (Type found) = \"".concat(errorLog.found, "\". \n\n The Type used is invalid for value: \"").concat(errorLog.value, "\". \n\n see logged error for details\n---------------------\n\n"));
}
function pushToErrorLogs(inputVal, tests) {
  typeErrorLogs.push({
    value: JSON.stringify(inputVal),
    tests: JSON.stringify(tests),
    found: (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(inputVal)
  });
}

/**
* _TypeCheck
* @param {any} inputVal
* @param {string} typeExp
* @param {object | string} params Parameters for the typeCheck function. 
* @return {bool | any} TypeChecker By default it returns boolean, but if '.return()' is used it will return the inputVal
* @example typeCheck(1, 'number') // true
* @example typeCheck([1], '[number]') // true
* @example typeCheck({x: 1, y: 2}, '{any: number}') // true
* @example typeCheck({ x: 'string', y: 10 }, '{y: number, x: string}', ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @usage (anyInputValue, stringTypeExpression, params: object | string)
* @usage params: object = { log: boolean, fail: boolean, callback: function }
* @usage params: string = 'log' | 'fail' | callback: function
* @usage chain Methods: log(), fail(), return() // returns the input value, test() returns the boolean
* @notes This function cannot validate the return value of a function when the validOutput is provided, use _tcx instead
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see testUnit for more examples and test cases   
*/
var _typeCheck = function _typeCheck(inputVal, typeExp, params) {
  return new ( /*#__PURE__*/function () {
    function _class() {
      var _this$settings$callba;
      _classCallCheck(this, _class);
      this.unitTest = (0,_testBuilder_js__WEBPACK_IMPORTED_MODULE_1__.testBuilder)(typeExp);
      this.testResult = runRouteTest(inputVal, this.unitTest);
      this.bool = this.testResult;
      this.settings = getSettings(params);
      this.callback = (_this$settings$callba = this.settings.callback) !== null && _this$settings$callba !== void 0 ? _this$settings$callba : null;
      this.testData = {
        typeExp: typeExp,
        inputVal: inputVal,
        inputType: (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(inputVal),
        callback: this.callback,
        unitTest: this.unitTest,
        testResult: this.testResult
      };
      if (this.settings.log) {
        this.log();
      }
      if (this.settings.fail) {
        this.fail();
      }
      if (this.callback) {
        this.callback(this.testData);
      }
    }
    return _createClass(_class, [{
      key: "test",
      value: function test() {
        return this.testResult;
      }
    }, {
      key: "log",
      value: function log() {
        console.log('-------------------------- \n ::: Test Data Info :::');
        console.table(this.testData);
        return this;
      }
    }, {
      key: "fail",
      value: function fail() {
        if (!this.testResult) {
          var _this$settings;
          this.log();
          ((_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : _this$settings.error) && console.log('\n\n-----> Error Message: ', this.settings.error);
          return typeError(inputVal);
        }
        return this;
      }
    }, {
      key: "return",
      value: function _return() {
        return inputVal;
      }
    }]);
  }())();
};

/**
* _tc is a helper function to wrap a function with typeCheck
* It is basic but faster the _tcx (neglible but if micro-optimization is needed)
* @param {array} typeExp array of types to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function.
* @return {function} Wrapped function
* @example _tc('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: string }
* @usage params: string = 'log' | 'fail' | 'return' 
* @usage defaults: log = false, fail = true, return = false
* @notes this function does not accept callback arguments and when using shorthand arguments (string) it does not accept validOutput
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see directory test for more information and examples
*/
var _tc = function _tc(typeExp, __function) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function () {
    params = _objectSpread(_objectSpread({}, {
      fail: true
    }), params);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _typeCheck(args, typeExp, params);
    return __function.apply(void 0, args);
  };
};

/**
* _tcx is a helper function to wrap a function with typeCheck
* It is as performant as the _tc but it has a lot more features to offer
* @param {string} typeExp Expression to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function. 
* @return {function} Wrapped function
* @example _tcx('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: stringTypeExpression }
* @usage params: string = 'log' | 'fail' | 'return'
* @notes This function can validate the return value of a function when the validOutput is provided
* @feature Return value validation
* @feature all instances accept individual fail, log, and return
* @feature all instances accept chaining parameters: myCoolFunction(44.5, 'yes!').log().fail().return()
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* Params: validOutput = stringTypeExpression ; // validate the return value of the function
* @see directory test for more information and examples
*/
var _tcx = function _tcx(typeExp, __function, params) {
  var $settings = getSettings(params);
  //set default as true
  $settings = _objectSpread(_objectSpread({}, {
    fail: true
  }), $settings);
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return new ( /*#__PURE__*/function () {
      function _class2() {
        _classCallCheck(this, _class2);
        this.args = args;
        this.testResults = _typeCheck(args, typeExp, $settings);
        return this["default"]();
      }
      return _createClass(_class2, [{
        key: "default",
        value: function _default() {
          var _$settings$validOutpu;
          this.returns = __function.apply(void 0, args);
          var validOutput = (_$settings$validOutpu = $settings.validOutput) !== null && _$settings$validOutpu !== void 0 ? _$settings$validOutpu : false;
          if (validOutput) {
            _typeCheck(this.returns, validOutput, 'fail');
          }
          return this;
        }
      }, {
        key: "log",
        value: function log() {
          this.testResults.log();
          return this;
        }
      }, {
        key: "fail",
        value: function fail() {
          this.testResults.fail();
          return this;
        }
      }, {
        key: "return",
        value: function _return() {
          return this.returns;
        }
      }]);
    }())();
  };
};

/**
 * Test the type but does not throw an error, althought it can use the rest of the chain methods
 * @param {any} inputVal
 * @param {string} typeExp
 */
var validType = function validType(inputVal, typeExp) {
  return _typeCheck(inputVal, typeExp).test();
};

/**
* typeCheck
* @param {any} inputVal
* @param {string} typeExp
* @example typeCheck(1, 'number') // true
* @example typeCheck([1], '[number]') // true
* @example typeCheck({x: 1, y: 2}, '{any: number}') // true
* @example typeCheck({ x: 'string', y: 10 }, '{y: number, x: string}', ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @see testUnit for more examples and test cases   
*/
var typeCheck = function typeCheck(inputVal, typeExp) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return _typeCheck(inputVal, typeExp, params).fail();
};


/***/ }),

/***/ "../type-check/src/types.js":
/*!**********************************!*\
  !*** ../type-check/src/types.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   typesMap: () => (/* binding */ typesMap)
/* harmony export */ });
/* harmony import */ var _knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/utility */ "../utility/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// typeOf is used here insteand of the native typeof because it can handle better the identifications of arrays and objects

var typesMap = new Map([['array', function (_var_) {
  return (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_var_, 'array');
}], ['bigInt', function (_var_) {
  return typeof _var_ === 'bigint';
}], ['boolean', function (_var_) {
  return typeof _var_ === 'boolean';
}], ['date', function (_var_) {
  return _var_ instanceof Date;
}], ['float', function (_var_) {
  return typeof _var_ === 'number' && !Number.isInteger(_var_);
}], ['function', function (_var_) {
  return typeof _var_ === 'function';
}], ['int', function (_var_) {
  return Number.isInteger(_var_);
}], ['map', function (_var_) {
  return _var_ instanceof Map;
}], ['null', function (_var_) {
  return _var_ === null;
}], ['number', function (_var_) {
  return typeof _var_ === 'number';
}], ['object', function (_var_) {
  return (0,_knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_var_, 'object');
}], ['promise', function (_var_) {
  return _var_ instanceof Promise;
}], ['regExp', function (_var_) {
  return _var_ instanceof RegExp;
}], ['set', function (_var_) {
  return _var_ instanceof Set;
}], ['string', function (_var_) {
  return typeof _var_ === 'string';
}], ['symbol', function (_var_) {
  return _typeof(_var_) === 'symbol';
}], ['undefined', function (_var_) {
  return typeof _var_ === 'undefined';
}], ['weakMap', function (_var_) {
  return _var_ instanceof WeakMap;
}], ['weakSet', function (_var_) {
  return _var_ instanceof WeakSet;
}]]);

/***/ }),

/***/ "../utility/index.js":
/*!***************************!*\
  !*** ../utility/index.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* reexport safe */ _src_domObserver_js__WEBPACK_IMPORTED_MODULE_0__.DomObserver),
/* harmony export */   ElementHelper: () => (/* reexport safe */ _src_ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   EventBus: () => (/* reexport safe */ _src_event_bus_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   addQuotes: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.addQuotes),
/* harmony export */   cleanStr: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.convertKeysToSymbols),
/* harmony export */   convertToBool: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.convertToBool),
/* harmony export */   convertToNumber: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.currencyToDecimal),
/* harmony export */   dateFormat: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.dateFormat),
/* harmony export */   decimalToCurrency: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.decimalToCurrency),
/* harmony export */   doAsync: () => (/* reexport safe */ _src_promiseQueue_js__WEBPACK_IMPORTED_MODULE_4__.doAsync),
/* harmony export */   doPoll: () => (/* reexport safe */ _src_promiseQueue_js__WEBPACK_IMPORTED_MODULE_4__.doPoll),
/* harmony export */   doTimeout: () => (/* reexport safe */ _src_promiseQueue_js__WEBPACK_IMPORTED_MODULE_4__.doTimeout),
/* harmony export */   domObserver: () => (/* reexport safe */ _src_domObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   elementHelper: () => (/* reexport safe */ _src_ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__.elementHelper),
/* harmony export */   emptyOrValue: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.emptyOrValue),
/* harmony export */   findAndReplaceInArray: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.findAndReplaceInArray),
/* harmony export */   findNested: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.findNested),
/* harmony export */   fixQuotes: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.fixQuotes),
/* harmony export */   formatPhoneNumber: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.formatPhoneNumber),
/* harmony export */   getArrObjFromString: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.getArrObjFromString),
/* harmony export */   getChunks: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.getChunks),
/* harmony export */   getDirectivesFromString: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.getDirectivesFromString),
/* harmony export */   getDynamicId: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.getGoogleMapsAddress),
/* harmony export */   getMatchBlock: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.getMatchInBetween),
/* harmony export */   getObjectFromPath: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.getObjectFromPath),
/* harmony export */   getRandomId: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.getRandomId),
/* harmony export */   includes: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.includes),
/* harmony export */   instanceOf: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.instanceOf),
/* harmony export */   isEmpty: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.isEmpty),
/* harmony export */   isNumber: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.isNumber),
/* harmony export */   makeArray: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.makeArray),
/* harmony export */   openGoogleMapsAddress: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.openGoogleMapsAddress),
/* harmony export */   promisePool: () => (/* reexport safe */ _src_promiseQueue_js__WEBPACK_IMPORTED_MODULE_4__.promisePool),
/* harmony export */   promiseQueue: () => (/* reexport safe */ _src_promiseQueue_js__WEBPACK_IMPORTED_MODULE_4__.promiseQueue),
/* harmony export */   proxyClass: () => (/* reexport safe */ _src_proxyObject_js__WEBPACK_IMPORTED_MODULE_5__.proxyClass),
/* harmony export */   proxyObject: () => (/* reexport safe */ _src_proxyObject_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   randomId: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.randomId),
/* harmony export */   removeQuotes: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.removeQuotes),
/* harmony export */   selectElement: () => (/* reexport safe */ _src_ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__.selectElement),
/* harmony export */   setExpString: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.setExpString),
/* harmony export */   setLookUpExp: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.setLookUpExp),
/* harmony export */   setWildCardString: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.setWildCardString),
/* harmony export */   startAndEndWith: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.startAndEndWith),
/* harmony export */   toCurrency: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.toCurrency),
/* harmony export */   toDollarString: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.toDollarString),
/* harmony export */   typeOf: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.typeOf),
/* harmony export */   uniqueId: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.uniqueId),
/* harmony export */   urlHelper: () => (/* reexport safe */ _src_urlHelper_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   uuid: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.uuid),
/* harmony export */   validateEmail: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.validateEmail),
/* harmony export */   validatePhone: () => (/* reexport safe */ _src_utility_js__WEBPACK_IMPORTED_MODULE_7__.validatePhone),
/* harmony export */   wildCardStringSearch: () => (/* reexport safe */ _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__.wildCardStringSearch)
/* harmony export */ });
/* harmony import */ var _src_domObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/domObserver.js */ "../utility/src/domObserver.js");
/* harmony import */ var _src_ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/ElementHelper.js */ "../utility/src/ElementHelper.js");
/* harmony import */ var _src_event_bus_EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/event-bus/EventBus.js */ "../utility/src/event-bus/EventBus.js");
/* harmony import */ var _src_powerHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/powerHelper.js */ "../utility/src/powerHelper.js");
/* harmony import */ var _src_promiseQueue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/promiseQueue.js */ "../utility/src/promiseQueue.js");
/* harmony import */ var _src_proxyObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/proxyObject.js */ "../utility/src/proxyObject.js");
/* harmony import */ var _src_urlHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/urlHelper.js */ "../utility/src/urlHelper.js");
/* harmony import */ var _src_utility_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/utility.js */ "../utility/src/utility.js");
// Single Modules and Aliases from: domObserver

// Default Module from: domObserver

// Single Modules and Aliases from: ElementHelper

// Default Module from: ElementHelper

// Default Module from: EventBus

// Single Modules and Aliases from: powerHelper

// Single Modules and Aliases from: promiseQueue

// Single Modules and Aliases from: proxyObject

// Default Module from: proxyObject

// Default Module from: urlHelper

// Single Modules and Aliases from: utility



/***/ }),

/***/ "../utility/src/ElementHelper.js":
/*!***************************************!*\
  !*** ../utility/src/ElementHelper.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ElementHelper: () => (/* binding */ ElementHelper),
/* harmony export */   "default": () => (/* binding */ ElementHelper),
/* harmony export */   elementHelper: () => (/* binding */ elementHelper),
/* harmony export */   selectElement: () => (/* binding */ selectElement)
/* harmony export */ });
/* harmony import */ var _domObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domObserver.js */ "../utility/src/domObserver.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower



/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {String|Object} selector Class or ID or DOM element
 * @param {String} scope The scope to search in, window, document, dom element. Defaults to document
 * @return {Object}
 * @example new ElementHelper('elementSelector')
 * @example new ElementHelper('elementSelector', domElement|window|document)
 *
 */
var ElementHelper = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector
   * @return {Object}
   */
  function ElementHelper(selector) {
    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    _classCallCheck(this, ElementHelper);
    _domObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"].start();
    this.selector = selector;
    if (_typeof(selector) === 'object') {
      this.domElement = selector;
    } else if (String(selector).includes('//')) {
      this.domElement = this.getElementByXpath(selector);
    } else {
      this.domElement = scope.querySelector(selector);
    }
  }

  // =========================================
  // --> Public
  // --------------------------

  /**
   * Check if the element exists or is visible. It will keep querying
   * @return {Boolean}
   */
  return _createClass(ElementHelper, [{
    key: "isInDom",
    value: function isInDom() {
      var _this$domElement;
      return Boolean((_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.outerHTML);
    }

    /**
     * Wait for element exists or is visible. It will keep querying
     * @function whenInDom
     * @return {Promise}
     */
  }, {
    key: "whenInDom",
    value: function whenInDom() {
      var $this = this;
      var callbackId = Date.now() + Math.floor(Math.random() * 1000);
      return new Promise(function (resolveThis) {
        if (!$this.isInDom()) {
          _domObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"].addOnNodeChange(callbackId, function () {
            var element = new ElementHelper($this.selector);
            if (element.isInDom()) {
              $this = element;
              resolveThis($this);
              _domObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"].removeOnNodeChange(callbackId);
            }
          });
        } else {
          resolveThis($this);
        }
      });
    }

    /**
     * Find element by Xpath string
     * @param {String} xpath
     * @example getElementByXpath("//html[1]/body[1]/div[1]")
     * @return {Object} DOM element
     */
  }, {
    key: "getElementByXpath",
    value: function getElementByXpath(xpath) {
      return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    }

    /**
     * Get the element xpath string
     * @author Based on https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reload-to-the-same-place-even-if/2631931#2631931
     * @return {String}
     */
  }, {
    key: "getXpathTo",
    value: function getXpathTo() {
      var element = this.domElement;
      if (element.id) {
        return "//*[@id='".concat(element.id, "']");
      }
      if (element === document.body) {
        return '//' + element.tagName;
      }
      var ix = 0;
      var siblings = element.parentNode.childNodes;
      for (var i = 0; i < siblings.length; i++) {
        var sibling = siblings[i];
        if (sibling === element) {
          return new ElementHelper(element.parentNode).getXpathTo() + '/' + element.tagName + '[' + (ix + 1) + ']';
        }
        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
          ix++;
        }
      }
    }

    /**
     * Get the element attribute, but parse it if it is an object or array
     * @param {String} attr Atrribute name
     * @return {String|Array|Object|Null}
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(attr) {
      return this.domElement.getAttribute(attr) || null;
    }

    /**
     * Create a unique has for the element derived from its xpath
     * @author Based on https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/
     * @return {String}
     */
  }, {
    key: "getHash",
    value: function getHash() {
      var string = String(this.getXpathTo());
      var hash = 0;
      if (string.length === 0) {
        return hash;
      }
      for (var i = 0; i < string.length; i++) {
        var _char = string.charCodeAt(i);
        hash = (hash << 5) - hash + _char;
        hash = hash & hash;
      }
      return hash;
    }
  }]);
}(); // =========================================
// --> Utilities
// --------------------------
var selectElement = function selectElement(selector) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return new ElementHelper(selector, scope);
};
var elementHelper = function elementHelper(selector) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return new ElementHelper(selector, scope);
};

/**
 * Future
 * @private
 * @todo enhance to extend the prototype like https://stackoverflow.com/questions/779880/in-javascript-can-you-extend-the-dom
 */



/***/ }),

/***/ "../utility/src/domObserver.js":
/*!*************************************!*\
  !*** ../utility/src/domObserver.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* binding */ domObserver),
/* harmony export */   "default": () => (/* binding */ domObserver),
/* harmony export */   domObserver: () => (/* binding */ domObserver)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
var executeOnNodeChanged = {};
var observer;
/**
 * When node change
 * @param {String} id
 * @param {Function} callback Callback when any node changes/ add/deleted/modified
 * @memberof DomObserver
 * @usage domObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @return {Void}
 */
var addOnNodeChange = function addOnNodeChange(id, callback) {
  if (callback) {
    executeOnNodeChanged[id] = callback;
  }
};
/**
 * Remove from node change
 * @param {String} id
 * @memberof DomObserver
 * @usage domObserver.removeOnNodeChange('elementIdentifier')
 * @return {Void}
 */
var removeOnNodeChange = function removeOnNodeChange(id) {
  if (id) {
    delete executeOnNodeChanged[id];
  }
};
/**
 * Deep cleanup
 * @return {Void}
 */
var cleanup = function cleanup() {
  Object.keys(executeOnNodeChanged).forEach(function (key) {
    return delete executeOnNodeChanged[key];
  });
};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
var start = function start() {
  if (typeof window !== 'undefined' && !observer) {
    var callback = function callback(mutationList) {
      var _iterator = _createForOfIteratorHelper(mutationList),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var mutation = _step.value;
          if (mutation.type === 'childList') {
            for (var id in executeOnNodeChanged) {
              executeOnNodeChanged[id]();
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    var config = {
      childList: true,
      subtree: true
    };
    observer = new MutationObserver(callback);
    if (document.body) {
      return observer.observe(document.body, config);
    }
    document.addEventListener('DOMContentLoaded', function (event) {
      return observer.observe(document.body, config);
    });
  }
};
/**
 * @exports domObserver
 * @type {Object}
 * @usage domObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @usage domObserver.removeOnNodeChange('elementIdentifier')
 * @usage domObserver.cleanup()
 */
var domObserver = {
  start: start,
  addOnNodeChange: addOnNodeChange,
  removeOnNodeChange: removeOnNodeChange,
  cleanup: cleanup
};


/***/ }),

/***/ "../utility/src/event-bus/EventBus.js":
/*!********************************************!*\
  !*** ../utility/src/event-bus/EventBus.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventBus: () => (/* binding */ EventBus),
/* harmony export */   "default": () => (/* binding */ EventBus)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var EventBus = /*#__PURE__*/function () {
  function EventBus() {
    _classCallCheck(this, EventBus);
    // cleanup
    this.listeners = {};
  }
  // creates an event that can be triggered any number of times
  /**
   * creates an event that can be triggered any number of times
   * @method on
   * @param {string} eventName - The name of the event
   * @param {function} callback - The callback to execute
   * @return {void}
   * @example EventBus.on('event.name', function() { console.log('event.name was triggered') })
   */
  return _createClass(EventBus, [{
    key: "on",
    value: function on(eventName, callback) {
      this.registerListener(eventName, callback);
    }
    /**
     * creates an event that can be triggered only once. If it is emitted twice, the callback will only be executed once!
     * @method once
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example EventBus.once('event.name', function() { console.log('event.name was triggered only once') })
     */
  }, {
    key: "once",
    value: function once(eventName, callback) {
      this.registerListener(eventName, callback, 1);
    }
    /**
     * reates an event that can be triggered only a number of times. If it is emitted more than that, the callback will not be be executed anymore!
     * @method exactly
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example EventBus.exactly('event.name', function() { console.log('event.name was triggered 3 times') }, 3)
     */
  }, {
    key: "exactly",
    value: function exactly(eventName, callback, capacity) {
      this.registerListener(eventName, callback, capacity);
    }
    /**
     * kill an event with all it's callbacks
     * @method off
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example EventBus.off('event.name')
     */
  }, {
    key: "off",
    value: function off(eventName) {
      delete this.listeners[eventName];
    }
    /**
     * removes the given callback for the given event
     * @method detach
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to remove
     * @return {void|boolean} - Returns true if the event was found and removed, void otherwise
     * @example EventBus.detach('event.name', callback)
     */
  }, {
    key: "detach",
    value: function detach(eventName, callback) {
      var listenersRecords = this.listeners[eventName] || [];
      var filteredListeners = listenersRecords.filter(function (value) {
        return value.callback !== callback;
      });
      if (eventName in this.listeners) {
        this.listeners[eventName] = filteredListeners;
        return true; // Event was found and removed
      }
      return false; // Event was not found
    }

    /**
     * emits an event with the given name and arguments
     * @param {string} eventName - The name of the event
     * @param {any} args - The arguments to pass to the callback
     * @return {void}
     * @use {__context: this|Instance} to pass the context to the callback
     * @example EventBus.emit('event.name', arg1, arg2, arg3)
     * @example EventBus.emit('event.name', arg1, arg2, arg3, {__context: YourInstance})
     */
  }, {
    key: "emit",
    value: function emit(eventName) {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var queueListeners = [];
      var matches = null;
      var allArgs = this.extractContextFromArgs(args);
      var context = allArgs[0];
      args = allArgs[1];

      // name exact match
      if (this.hasListener(eventName)) {
        queueListeners = this.listeners[eventName];
      } else {
        // -----------------------------------------
        // Wildcard support
        if (eventName.includes('*')) {
          // case 1, if the incoming string has * or ** in it
          // Matches the emit 'eventName' to the registered 'on' this.listeners
          matches = this.patternSearch(eventName, Object.keys(this.listeners));
          if (matches.length > 0) {
            matches.forEach(function (match) {
              queueListeners = queueListeners.concat(_this.listeners[match]);
            });
          }
        } else {
          // case 2, if the incoming string does not have * or ** in it
          // get the patterns from the this.listeners (on method) and match them to the emit name
          for (var key in this.listeners) {
            if (key.includes('*')) {
              matches = this.patternSearch(key, [eventName]);
              if (matches) {
                queueListeners = queueListeners.concat(this.listeners[key]);
              }
            }
          }
        }
      }
      queueListeners.forEach(function (listener, k) {
        var callback = listener.callback;
        if (context) {
          callback = callback.bind(context);
        }
        if (listener.triggerCapacity !== undefined) {
          listener.triggerCapacity--;
          queueListeners[k].triggerCapacity = listener.triggerCapacity;
        }
        if (_this.checkToRemoveListener(listener)) {
          _this.listeners[eventName].splice(k, 1);
        }
        callback.apply(void 0, _toConsumableArray(args));
      });
    }
    /**
     * Search for a pattern in a list of strings
     * @method patternSearch
     * @private
     * @param {string} pattern - The pattern to search for
     * @param {string[]} list - The list of strings to search in
     * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
     * @example patternSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
     */
  }, {
    key: "patternSearch",
    value: function patternSearch(pattern, list) {
      var filteredList = [];
      // console.log('__testLogHere__', pattern, this.setWildCardString(pattern));
      var regex = new RegExp(this.setWildCardString(pattern), 'g');
      filteredList = list.filter(function (item) {
        return regex.test(item);
      });
      return filteredList.length === 0 ? null : filteredList;
    }
  }, {
    key: "setWildCardString",
    value: function setWildCardString(string) {
      // eslint-disable-next-line
      var regexStr = string.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
      // eslint-disable-next-line
      regexStr = regexStr.replace(/\*/g, '(.*?)');
      return "^".concat(regexStr);
    }
    /**
     * Extract the context from the arguments
     * @method extractContextFromArgs
     * @private
     * @param {any[]} args - The arguments to extract the context from
     * @return {any[]} - Returns an array with the context as the first element and the arguments as the second element
     */
  }, {
    key: "extractContextFromArgs",
    value: function extractContextFromArgs(args) {
      var context = null;
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        // eslint-disable-next-line
        if (arg && _typeof(arg) === 'object' && arg.hasOwnProperty('__context')) {
          context = arg.__context;
          args.splice(i, 1);
          break;
        }
      }
      return [context, args];
    }
  }, {
    key: "registerListener",
    value: function registerListener(eventName, callback, triggerCapacity) {
      if (!this.hasListener(eventName)) {
        this.listeners[eventName] = [];
      }
      this.listeners[eventName].push({
        callback: callback,
        triggerCapacity: triggerCapacity
      });
    }
  }, {
    key: "checkToRemoveListener",
    value: function checkToRemoveListener(eventInformation) {
      if (eventInformation.triggerCapacity !== undefined) {
        return eventInformation.triggerCapacity <= 0;
      }
      return false;
    }
  }, {
    key: "hasListener",
    value: function hasListener(eventName) {
      return eventName in this.listeners;
    }
  }]);
}();


/***/ }),

/***/ "../utility/src/powerHelper.js":
/*!*************************************!*\
  !*** ../utility/src/powerHelper.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addQuotes: () => (/* binding */ addQuotes),
/* harmony export */   cleanStr: () => (/* binding */ cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* binding */ convertKeysToSymbols),
/* harmony export */   findAndReplaceInArray: () => (/* binding */ findAndReplaceInArray),
/* harmony export */   findNested: () => (/* binding */ findNested),
/* harmony export */   fixQuotes: () => (/* binding */ fixQuotes),
/* harmony export */   getArrObjFromString: () => (/* binding */ getArrObjFromString),
/* harmony export */   getChunks: () => (/* binding */ getChunks),
/* harmony export */   getDirectivesFromString: () => (/* binding */ getDirectivesFromString),
/* harmony export */   getMatchBlock: () => (/* binding */ getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* binding */ getMatchInBetween),
/* harmony export */   getObjectFromPath: () => (/* binding */ getObjectFromPath),
/* harmony export */   removeQuotes: () => (/* binding */ removeQuotes),
/* harmony export */   setExpString: () => (/* binding */ setExpString),
/* harmony export */   setLookUpExp: () => (/* binding */ setLookUpExp),
/* harmony export */   setWildCardString: () => (/* binding */ setWildCardString),
/* harmony export */   startAndEndWith: () => (/* binding */ startAndEndWith),
/* harmony export */   wildCardStringSearch: () => (/* binding */ wildCardStringSearch)
/* harmony export */ });
/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utility.js */ "../utility/src/utility.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower



// @private
function _removeBrackets(strExp) {
  var regex = /^(\[|\{)(.*?)(\]|\})$/; // Match brackets at start and end
  var match = strExp.match(regex);
  if (match) {
    return match[2].trim(); // Extract and trim the content between brackets
  }
  return strExp; // Return the original string if no brackets found at start and end
}

/**
 * Add quotes to a string
 * @function addQuotes
 * @param {String} str
 * @return {String}
 * @example addQuotes('hello') // "hello"
 */
function addQuotes(str) {
  var q = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '"';
  return "".concat(q).concat(str).concat(q);
}

/**
 * Clean a string from delimeters or just trimmed if no delimeters given
 * @funtion cleanStr
 * @param {String} str - String to use
 * @param {String|Regex} p1 - Delimeter 1
 * @param {String|Regex} p2 - Delimeter 2
 * @return {String|void}
 * @example cleanStr('hello world', 'h', 'd') // 'ello worl'
 * @example cleanStr('  hello world  ') // 'hello world'
 * @example cleanStr('hello world', 'hello') // 'world'
 * @example cleanStr('Hello World. Sunshine is here!', '\..*!') // Hello World
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'
 */
function cleanStr(str) {
  if (!str) {
    return;
  }
  if (typeof str !== 'string') {
    return str;
  }
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return args.reduce(function (accStr, arg) {
    var regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));
    return accStr.replace(regex, '');
  }, str).trim();
}

/**
 * convert all keys from an object to symbols
 * @function convertKeysToSymbols
 * @param {object} obj - The object to convert
 * @return {object} - The object with all keys converted to symbols
 * @example convertKeysToSymbols({a: 1, b: 2}) // returns {Symbol(a): 1, Symbol(b): 2, keyToSymbolMap: {a: Symbol(a), b: Symbol(b)}
 */
function convertKeysToSymbols(obj) {
  if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(obj, null) === null) {
    return {};
  }
  var newObj = {};
  var keyToSymbolMap = {};
  for (var key in obj) {
    var symbolKey = Symbol(key);
    newObj[symbolKey] = obj[key];
    keyToSymbolMap[key] = symbolKey;
  }
  newObj.keyToSymbolMap = keyToSymbolMap;
  return newObj;
}

/**
 * Recursively will loop in array to find the desired target
 * @function findAndReplaceInArray
 * @param {Array} arr
 * @param {String} find The target (needle)
 * @param {Array|Object|String} value Replacer
 * @return {Null|Array}
 * @example findAndReplaceInArray([1,2,3,4,5], 3, 'three') // [1,2,'three',4,5]
 */
function findAndReplaceInArray(arr, find, value) {
  var replaced = false;
  var result = arr.map(function (prop) {
    if (Array.isArray(prop)) {
      var replacedArray = findAndReplaceInArray(prop, find, value);
      if (replacedArray) {
        replaced = true;
        return replacedArray;
      }
      return prop;
    }
    if (prop === find) {
      replaced = true;
      if (Array.isArray(value)) {
        return value.map(function (p) {
          return Array.isArray(p) ? p : p.trim();
        });
      }
      return value;
    }
    return prop;
  });
  return replaced ? result : null;
}

/**
 * Find the last instance of nested pattern with delimeters
 * @function findNested
 * @param {string} str
 * @param {string} start - Delimeter 1
 * @param {string} end - Delimeter 2
 * @return {string|null}
 * @example findNested('[[]hello [world]]', '[', ']') // [world]
 */
function findNested(str) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '[';
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ']';
  if (typeof str !== 'string') {
    return str;
  }
  // Find the last index of '['
  var lastIndex = str.lastIndexOf(start);
  // If '[' is not found, return null or some default value
  if (lastIndex === -1) {
    return null;
  }

  // Extract the substring starting from the last '[' to the end
  var substring = str.substring(lastIndex);
  // Find the index of the first ']' in the substring
  var endIndex = substring.indexOf(end);
  // If ']' is not found, return null or some default value
  if (endIndex === -1) {
    return null;
  }
  // Extract and return the content between the last '[' and the next ']', including them
  return substring.substring(0, endIndex + 1);
}

/**
 * Fix quotes from a string
 * @function fixQuotes
 * @param {String} str
 * @return {String} q quote type
 * @return {String}
 * @example fixQuotes("'hello'") // "hello"
 * @example fixQuotes('"hello"') // "hello"
 */
function fixQuotes(str) {
  var q = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '"';
  if (typeof str !== 'string') {
    return str;
  }
  return str.replace(/`|'|"/g, q);
}

/**
 * Get an object from a path
 * @function getObjectFromPath
 * @param {String} path - The path to the object
 * @param {Object} source - The source object to search in
 * @return {Object} - The object found at the path
 * @example getObjectFromPath('a.b.c', {a: {b: {c: 'value'}}}) // 'value'
 * @example getObjectFromPath('a.b.c') // 'value'
 * @example getObjectFromPath('a.b.c', window) // value
 * @example getObjectFromPath('a.b.c', source) // value
 */
function getObjectFromPath(path) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
  return path.split('.').reduce(function (acc, part) {
    return acc && acc[part];
  }, source);
}

/**
 * Converts strings formats into objects or arrays
 * Note: quoted strings are not supported, use getDirectiveFromString instead
 * @param {string} strExp
 * @return {object|array|string}
 * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']
 * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']
 * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }
 */
function getArrObjFromString(strExp) {
  // alredy typeof object or array just return it
  if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.typeOf)(strExp, 'object') || (0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.typeOf)(strExp, 'array')) {
    return strExp;
  }
  var isObject = startAndEndWith(strExp, '{', '}');
  var isArray = startAndEndWith(strExp, '[', ']');
  // If it is other type of string, return it
  if (!isObject && !isArray) {
    return strExp;
  }
  var newCollection = isObject ? {} : [];
  var nestedElements = {};

  //remove the brackets
  var newStrExp = _removeBrackets(strExp);
  var loopNested = function loopNested() {
    var objects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    // ignore eslint comment
    // eslint-disable-next-line no-constant-condition
    while (true) {
      //find any nested arrays or objects
      var matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);
      if (!matched) {
        break;
      }

      //replace the nested array or object with a marker so that we can safely split the string
      var marker = "__".concat((0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.getRandomId)(), "__");
      nestedElements[marker] = matched;
      newStrExp = newStrExp.replace(matched, marker);
    }
  };
  loopNested();
  loopNested(true);
  getChunks(newStrExp).forEach(function (chunk, index) {
    var isObjectKey = chunk.includes(':') && isObject;
    var chunkParts = isObjectKey ? getChunks(chunk, ':') : [];
    var chunkKey = removeQuotes((0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(chunkParts[0], index));
    chunk = isObjectKey ? chunkParts[1] : chunk;
    if (chunk in nestedElements) {
      chunk = getArrObjFromString(nestedElements[chunk]);
    }
    chunk = (0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(removeQuotes(chunk));
    // set back in the collection either as an object or array
    isObject ? newCollection[chunkKey] = chunk : newCollection.push(chunk);
  });
  // uncomment to debug
  // console.log('___ log ___', newCollection);
  return newCollection;
}

/**
 * handles the following patterns to get an object from string attributes
 * // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
 * // Matches the Array as string: [value, value] OR ['value','value']
 * // Matches a multi-array string like [[value,value]],value]
 * // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
 * // Matches string ID or class: literals Id(#) or class (.). Note that in Vue it needs to be in quotes attr="'#theId'"
 * // Mathes simple directive function style: directive(#idOr.Class)
 * Note: all the above with the exception of the Id/class will be converted into actual objects
 */
/**
 * Converts strings formats into objects
 * @function getDirectivesFromString
 * @param {String|Array|Object} stringDirective
 * @return {object|null|void}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 * @example getDirectivesFromString('[[value,value],value]') // {directive: 'values', directive2: 'values'}
 * @example getDirectivesFromString('directive.tablet|mobile(...values)') // {directive: {tablet: 'values', mobile: 'values'}}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 */
function getDirectivesFromString(stringDirective) {
  var str = stringDirective;
  if (!(0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(str)) {
    return null;
  }
  var results = function results() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return {
      type: type,
      directive: results
    };
  };
  var matchArrayTypes = /^\[((.|\n)*?)\]$/gm;
  // comment eslint to ignore
  // eslint-disable-next-line no-useless-escape
  var matchObjectTypes = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
  // eslint-disable-next-line no-useless-escape
  var matchFunctionString = /^([a-zA-Z]+)(\()(\.|\#)(.*)(\))/g;
  var regexDotObjectString = /([a-zA-Z]+)\.(.*?)\(((.|\n)*?)\)/gm;
  var regexExObjectString = /([a-zA-Z]+)\[((.|\n)*?)\]\(((.|\n)*?)\)/gm;
  var type = _typeof(str);
  if (type === 'object' || type === 'array') {
    return results(type, str);
  } else {
    switch (true) {
      case !!str.match(matchArrayTypes):
        // Matches the Array as string: [value, value] OR ['value','value']
        // regexArrayLike = /^\[((.|\n)*?)\]$/gm;
        // Matches a multi-array string like [[value,value]],value]
        // regexMultiArrayString = /\[(\n|)(((.|\[)*)?)\](\,\n|)(((.|\])*)?)(\n|)\]/gm;

        type = 'array';
        break;
      case !!str.match(matchObjectTypes):
        // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
        // regexObjectLike = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
        type = 'object';
        break;
      case !!str.match(matchFunctionString):
        // Mathes simple directive function style: directive(#idOr.Class)
        // regexFunctionString
        // eslint-disable-next-line
        var directive = str.split('(')[0].trim();
        return results('idOrClassWithDirective', _defineProperty({}, directive, getMatchInBetween(str, '(', ')')));
      case !!str.match(regexDotObjectString):
        // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
        // OR directive.breakdown|breakdown2(...values) OR directive.tablet(...values)&&directive.mobile(...values)
        type = 'dotObject';
        break;
      case !!str.match(regexExObjectString):
        type = 'dotObject';
        break;
      default:
        return results('string', str);
    }
  }
  if (type === 'array' || type === 'object') {
    var strQ = fixQuotes(str);
    try {
      return results(type, JSON.parse(strQ));
    } catch (error) {
      // uncomment to debug
      // console.log('___ parse error ___', error);
    }
    return results(type, getArrObjFromString(strQ));
  }
  if (type === 'dotObject') {
    var values, breakDownId, _directive;
    var setObject = {};
    getChunks(str, '&&').forEach(function (command) {
      if (command.match(regexExObjectString)) {
        // Matches object-style strings: directive[expression](...values)
        values = getMatchInBetween(command, '](', ')');
        breakDownId = getMatchInBetween(command, '[', ']');
        _directive = command.split('[')[0].trim();
      } else {
        // Matches object-style strings: directive.tablet(...values)
        values = getMatchInBetween(command, '(', ')');
        command = command.replace(getMatchBlock(command, '(', ')'), '');
        var _getChunks = getChunks(command, '.');
        var _getChunks2 = _slicedToArray(_getChunks, 2);
        _directive = _getChunks2[0];
        breakDownId = _getChunks2[1];
      }
      values = getArrObjFromString(values);
      if (!setObject[_directive]) {
        setObject[_directive] = {};
      }
      getChunks(breakDownId, '|').forEach(function (id) {
        setObject[_directive][id] = values;
      });
    });
    return results('dotObject', setObject);
  }
}

/**
 * Find math by delimeters returns raw matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchBlock('is a hello world today', 'h', 'd') // 'hello world'
 * @example getMatchBlock('is a hello world today', 'h', 'd', true) // ['hello world']
 * @example getMatchBlock('is a <hello world/> today', '<', '/>') // '<hello world/>'
 */
function getMatchBlock(str, p1, p2) {
  var all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (typeof str !== 'string') {
    return str;
  }
  p1 = setExpString(p1);
  p2 = setExpString(p2);
  var regex = new RegExp(setLookUpExp(p1, p2), 'gm');
  var matches = str.match(regex);
  if (matches) {
    return all ? matches : matches[0];
  }
  return null;
}
/**
 * Splits a string into chunks by a given splitter and cleans the chunks
 * @param {string} str
 * @param {string} splitter - The string/character to split the string by. Defaults to ','
 * @return {string|array}
 */
function getChunks(str) {
  var splitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
  if (typeof str !== 'string') {
    return str;
  }
  if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(str)) {
    return [];
  }
  str = cleanStr(str);
  var chunks = str.split(splitter).map(function (t) {
    return cleanStr(t);
  });
  return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;
}

/**
 * find a match in between two delimeters, either string or regex given, returns clean matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchInBetween('hello world', 'h', 'd') // 'ello worl'
 * @example getMatchInBetween('hello <world/>', '<', '/>', true) // ['world']
 * @example getMatchInBetween('hello <world/>', '<', '/>') // 'world'
 */
function getMatchInBetween(str, p1, p2) {
  var _getMatchBlock;
  var all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (typeof str !== 'string') {
    return str;
  }
  var matchBlock = (_getMatchBlock = getMatchBlock(str, p1, p2, all)) !== null && _getMatchBlock !== void 0 ? _getMatchBlock : all ? [] : str;
  return all ? matchBlock.map(function (match) {
    return cleanStr(match, p1, p2);
  }) : cleanStr(matchBlock, p1, p2);
}

/**
 * Remove quotes from a string
 * @function removeQuotes
 * @param {String} str
 * @return {String}
 * @example removeQuotes('"hello"') // hello
 * @example removeQuotes("'hello'") // hello
 */
function removeQuotes(str) {
  if (typeof str !== 'string') {
    return str;
  }
  return str.replace(/`|'|"/g, '');
}

/**
 * Checks if a string starts and ends with a given string
 * @param {string} strExp
 * @param {string} start - The string/character to check it starts with
 * @param {string} end - The string/character to check it ends with
 * @return {string}
 * @example startAndEndWith('hello world', 'h', 'd') // false
 * @example startAndEndWith('hello world', 'h', 'd') // true
 */
function startAndEndWith(strExp) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));
}

/**
 * Scapes a string to create a regex or returns the regex if it already is an expression
 * @function setExpString
 * @param {String|Regex} exp
 * @return {String|Regex}
 * @example setExpString('hello') // '\h\e\l\l\o'
 * @example setExpString(/hello/) // /hello/
 * @example setExpString([hello]) // \\[hello\\/ then use like new new RegExp(setExpString(StringOrRegex))
 */
function setExpString(exp) {
  if (exp instanceof RegExp) {
    return exp;
  } else {
    return exp.split('').map(function (_char) {
      return ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\'].includes(_char) ? "\\".concat(_char) : _char;
    }).join('');
  }
}

/**
 * Regex builder to get a match in between two delimeters
 * @function setLookUpExp
 * @param {String|Regex} args - minimun two arguments as delimeters
 * @return {String} - Regex
 * @example setLookUpExp('h', 'd') // 'h((.|\n)*?)d'
 * @example setLookUpExp('h', 'd', 'c') // 'h((.|\n)*?)d((.|\n)*?)c'
 * @usage:
 * const pattern = setLookUpExp(".", "!");
const regex = new RegExp(pattern, 'g');
const text = "Hello World. Sunshine is here! Have fun!";
const matches = text.match(regex);
console.log(matches);  // Output: [". Sunshine is here!"]
 */
function setLookUpExp() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (args.length < 2) {
    throw new Error('You need to pass at least two arguments');
  }
  var expression = '';
  // loop through args
  args.forEach(function (arg, index) {
    // if arg is a regex, return the source
    if (arg instanceof RegExp) {
      arg = arg.source;
    }
    if (index === 0) {
      expression = arg;
    } else {
      expression += "((.|\n)*?)".concat(arg);
    }
  });
  return expression;
}

/**
 * Set a string to be used as a wildcard pattern
 * @function setWildCardString
 * @param {string} string - The string to set as a wildcard pattern
 * @param {boolean} matchStart - If the pattern should match the start of the string
 * @param {boolean} matchEnd - If the pattern should match the end of the string
 * @return {string} - The wildcard pattern
 * @example setWildCardString('name.*', true) // returns '^name\.(.*?)'
 * @example setWildCardString('name.*', false, true) // returns 'name\.(.*?)$'
 * @example setWildCardString('name.**') // returns 'name\..*' greedy
 */
function setWildCardString(str) {
  var matchStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var matchEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (typeof str !== 'string') {
    return str;
  }
  if (!str) {
    return null;
  }
  matchStart = (0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.convertToBool)(matchStart);
  matchEnd = (0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.convertToBool)(matchEnd);
  // eslint-disable-next-line no-useless-escape
  var regexStr = str.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
  var regStart = matchStart ? '^' : '';
  var regEnd = matchEnd ? '$' : '';
  regexStr = regexStr.replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
  .replace(/\*/g, '(.*?)').replace(/\[_g_\]/g, '.*');
  return "".concat(regStart).concat(regexStr).concat(regEnd);
}

/**
 * Search for a wildcard pattern in a list of strings or viceversa
 * @method wildCardStringSearch
 * @param {string} pattern - The pattern to search for
 * @param {array|string} list - The list of strings to search in
 * @param {boolean} matchStart - If the pattern should match the start of the string (optional)
 * @param {boolean} matchEnd - If the pattern should match the end of the string optional)
 * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
 * @example wildCardStringSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
 */
function wildCardStringSearch(pattern, listOrString) {
  var matchStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var matchEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (!pattern || !listOrString) {
    return null;
  }
  var regex = new RegExp(setWildCardString(pattern, matchStart, matchEnd));
  if (typeof listOrString === 'string') {
    var matches = listOrString.match(regex);
    return (0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(matches);
  }
  var filteredList = [];
  filteredList = listOrString.filter(function (item) {
    return regex.test(item);
  });
  return (0,_utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(filteredList);
}

//  const powerHelper = {
//     addQuotes,
//     cleanStr,
//     convertKeysToSymbols,
//     findAndReplaceInArray,
//     findNested,
//     fixQuotes,
//     getArrObjFromString,
//     getChunks,
//     getDirectivesFromString,
//     getMatchBlock,
//     getMatchInBetween,
//     getObjectFromPath,
//     removeQuotes,
//     startAndEndWith,
//     setExpString,
//     setLookUpExp,
//     setWildCardString,
//     wildCardStringSearch,
// };

/***/ }),

/***/ "../utility/src/promiseQueue.js":
/*!**************************************!*\
  !*** ../utility/src/promiseQueue.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doAsync: () => (/* binding */ doAsync),
/* harmony export */   doPoll: () => (/* binding */ doPoll),
/* harmony export */   doTimeout: () => (/* binding */ doTimeout),
/* harmony export */   promisePool: () => (/* binding */ promisePool),
/* harmony export */   promiseQueue: () => (/* binding */ promiseQueue)
/* harmony export */ });
/* harmony import */ var _event_bus_EventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-bus/EventBus.js */ "../utility/src/event-bus/EventBus.js");
/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utility.js */ "../utility/src/utility.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



/**
 * @class promisePool
 * @description Class to manage a pool of promises with status tracking.
 * @methods
 * add: Adds a promise to the pool and sets up handling for resolution.
 * status: Returns the overall status of the promise pool.
 * isDone: Returns true if the pool is done processing all promises.
 * clear: Clears all promises from the pool.
 * @returns {Object} An instance of the promisePool class.
 * @example
 * const pool = promisePool();
 * pool.add(fetch('https://jsonplaceholder.typicode.com/todos/1'));
 * pool.add(fetch('https://jsonplaceholder.typicode.com/todos/2'));
 * pool.status(); // 'in-progress'
 * pool.on('completed', () => {});
 * pool.on('rejected', (rejectedPromises) => {});
 * pool.on('stats', ({ completed, rejected, pending, total }) => {});
 */
var promisePool = function promisePool() {
  var _status = 'in-progress'; // 'in progress' or 'done'
  var promises = {};
  var rejectedPromises = [];
  return new ( /*#__PURE__*/function (_EventBus) {
    function _class() {
      _classCallCheck(this, _class);
      return _callSuper(this, _class);
    }
    /**
     * Adds a promise to the pool and sets up handling for resolution.
     * @param {Promise|Array} promise The promise to add to the pool.
     */
    _inherits(_class, _EventBus);
    return _createClass(_class, [{
      key: "add",
      value: function add(promise) {
        var isValidPromise = function () {
          if (promise instanceof Promise) {
            return true;
          }
          if (Array.isArray(promise)) {
            return promise.length > 0 && promise.every(function (item) {
              return item instanceof Promise;
            });
          }
          return false;
        }();
        if (!isValidPromise) {
          if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.typeOf)(promise, 'function')) {
            promise = new Promise( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve) {
                var fx;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return promise();
                    case 2:
                      fx = _context.sent;
                      resolve(fx);
                    case 4:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return function (_x) {
                return _ref.apply(this, arguments);
              };
            }());
          } else {
            console.error('---> Invalid promise added to the pool.');
            rejectedPromises.push(promise);
            return this.emit('fail', promise.toString());
          }
        }
        var $this = this;
        var promiseCollection = (0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.makeArray)(promise);
        promiseCollection.forEach(function (promise) {
          var promiseBag = Promise.all([promise]);
          var promiseId = (0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.getDynamicId)();
          promises[promiseId] = {
            promiseBag: promiseBag,
            status: 'in-progress'
          };
          promiseBag.then(function () {
            promises[promiseId].status = 'completed';
            $this._updateStatus();
          })["catch"](function () {
            promises[promiseId].status = 'rejected';
            $this._updateStatus();
          });
        });
      }

      /**
       * Returns the overall status of the promise pool.
       * @returns {String} The current status of the pool.
       */
    }, {
      key: "status",
      value: function status() {
        return _status;
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return _status === 'done';
      }
    }, {
      key: "_updateStatus",
      value: function _updateStatus() {
        if (_status === 'done') {
          return;
        }
        var instances = Object.values(promises);
        instances.forEach(function (promise) {
          if (promise.status === 'rejected') {
            rejectedPromises.push(promise);
          }
        });
        var statuses = instances.every(function (promise) {
          return promise.status === 'completed' || promise.status === 'rejected';
        });
        _status = statuses ? 'done' : 'in-progress';
        var stats = {
          completed: instances.filter(function (promise) {
            return promise.status === 'completed';
          }).length,
          rejected: rejectedPromises.length,
          pending: instances.filter(function (promise) {
            return promise.status === 'in-progress';
          }).length,
          total: instances.length
        };
        this.emit('stats', stats);
        if (_status === 'done') {
          this.emit('completed', stats);
          this.emit('rejected', rejectedPromises);
          this.clear();
        }
      }

      /**
       * Clears all promises from the pool.
       */
    }, {
      key: "clear",
      value: function clear() {
        promises = {};
        rejectedPromises = [];
      }
    }]);
  }(_event_bus_EventBus_js__WEBPACK_IMPORTED_MODULE_0__.EventBus))();
};

/**
 * @class promiseQueue
 * Class to manage a queue of promises, executing them sequentially with status tracking for each promise.
 * @extends EventBus
 * @methods
 * add: Adds a promise to the queue and starts the queue processing if not already started.
 * clear: Clears the promise queue.
 * status: Returns the current status of all promises in the queue.
 * @returns {Object} An instance of the promiseQueue class.
 * @example
 * const queue = promiseQueue();
 * queue.add(fetch('https://jsonplaceholder.typicode.com/todos/1'));
 * queue.add(fetch('https://jsonplaceholder.typicode.com/todos/2'));
 * queue.status(); // 'in-progress'
 * queue.on('completed', () => {});
 */
var promiseQueue = function promiseQueue() {
  return new ( /*#__PURE__*/function (_EventBus2) {
    function _class2() {
      var _this;
      _classCallCheck(this, _class2);
      _this = _callSuper(this, _class2);
      _this.queue = [];
      _this.inProgress = false;
      _this._timer = null;
      return _this;
    }

    /**
     * Adds a promise to the queue and starts the queue processing if not already started.
     * @param {Promise} promiseFunction A function that returns a promise.
     */
    _inherits(_class2, _EventBus2);
    return _createClass(_class2, [{
      key: "add",
      value: function add(promise) {
        var _this2 = this;
        var isValidPromise = function () {
          if (promise instanceof Promise) {
            return true;
          }
          if (Array.isArray(promise)) {
            return promise.length > 0 && promise.every(function (item) {
              return item instanceof Promise;
            });
          }
          return false;
        }();
        if (!isValidPromise) {
          if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.typeOf)(promise, 'function')) {
            promise = new Promise( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resolve) {
                var fx;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return promise();
                    case 2:
                      fx = _context2.sent;
                      return _context2.abrupt("return", resolve(fx));
                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              }));
              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }());
          } else {
            console.error('---> Invalid promise added to the Queue:', promise.toString());
            return this.emit('fail', promise.toString());
          }
        }
        (0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.makeArray)(promise).forEach(function (promiseFunction) {
          _this2.queue.push({
            promiseFunction: promiseFunction,
            status: 'pending' // 'pending', 'fulfilled', or 'rejected'
          });
        });
        if (!this.inProgress) {
          this._next();
        }
        this._setTimer();
      }

      /**
       * Clears the promise queue.
       */
    }, {
      key: "clear",
      value: function clear() {
        this.queue = [];
      }
    }, {
      key: "_setTimer",
      value: function _setTimer() {
        var _this3 = this;
        if (this._timer) {
          clearInterval(this._timer);
        }
        this._timer = setInterval(function () {
          if (_this3.status() === 'done') {
            _this3.emit('completed');
            clearInterval(_this3._timer);
            _this3._timer = null;
          }
        }, 10);
      }

      /**
       * Processes the next promise in the queue, if any.
       * @private
       */
    }, {
      key: "_next",
      value: function _next() {
        var _this4 = this;
        if (this.queue.length === 0) {
          this.inProgress = false;
          return;
        }
        this.inProgress = true;
        var promiseFunction = this.queue[0].promiseFunction;
        promiseFunction.then(function () {
          _this4.queue[0].status = 'fulfilled';
        })["catch"](function () {
          _this4.queue[0].status = 'rejected';
        })["finally"](function () {
          _this4.queue.shift(); // Remove the processed promise from the queue
          _this4._next(); // Process the next promise
        });
      }

      /**
       * Returns the current status of all promises in the queue.
       * @returns {Array<Object>} An array of objects with the status of each promise.
       */
    }, {
      key: "status",
      value: function status() {
        return this.queue.length === 0 ? 'done' : 'in-progress';
      }
    }]);
  }(_event_bus_EventBus_js__WEBPACK_IMPORTED_MODULE_0__.EventBus))();
};

/**
 * Creates a poll function that continuously calls a given function until it returns true or a promise resolves.
 * @param {Function} fn - The function to be polled. It can return a promise or a boolean.
 * @param {Object} options - Configuration options for polling.
 * @param {number} [options.interval=200] - The interval in milliseconds between each poll.
 * @param {number} [options.timeout=1000] - The maximum time in milliseconds to continue polling.
 * @returns {Object} { promise, stop } - An object containing the polling promise and a cancel function.
 * @fails returns 'failed' if the polling times out or is cancelled.
 * @options: {}
 * - interval: The interval in milliseconds between each poll.
 * - timeout: The maximum time in milliseconds to continue polling.
 * @example
 * const { promise, stop } = doPoll(() => {
 *    // Polling logic here
 *   return true; // or return a promise
 * }
 */
var doPoll = function doPoll(fn) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof fn !== 'function') {
    throw new Error('doPoll: The first argument must be a function.');
  }
  var _options$interval = options.interval,
    interval = _options$interval === void 0 ? 200 : _options$interval,
    _options$timeout = options.timeout,
    timeout = _options$timeout === void 0 ? 1000 : _options$timeout,
    _options$timeoutMsg = options.timeoutMsg,
    timeoutMsg = _options$timeoutMsg === void 0 ? '===> doPoll: cancelled or timed out.' : _options$timeoutMsg;
  var timeoutId, intervalId;
  var resolvePromise, rejectPromise;
  var stopped = false;
  var stop = function stop() {
    clearTimers();
    rejectPromise(console.info(timeoutMsg));
  };
  var done = function done(result) {
    clearTimers();
    resolvePromise(result);
  };
  function clearTimers() {
    stopped = true;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
  }
  var promise = new Promise(function (resolve, reject) {
    resolvePromise = resolve;
    rejectPromise = reject;
    var isPromise = fn instanceof Promise;
    var poll = function poll() {
      if (stopped) {
        return;
      }
      var pollThis = isPromise ? fn : fn();
      if (isPromise) {
        pollThis.then(function (resolvedValue) {
          if (resolvedValue) {
            done(resolvedValue);
          }
        })["catch"](rejectPromise);
      } else {
        if (Boolean(pollThis) || pollThis) {
          done(pollThis);
        }
      }
    };
    intervalId = setInterval(poll, interval);
    poll(); // Initial call to handle any immediate resolution

    timeoutId = setTimeout(function () {
      if (!stopped) {
        stop();
      }
    }, timeout);
  });
  return {
    promise: promise,
    stop: stop
  };
};

// =========================================
// --> doTimeout
// --------------------------
var doTimeoutStore = {};
/**
 * Initialize, cancel, or force execution of a callback after a delay using a unique ID.
 * If delay and callback are specified, a timeout is initialized. The callback will execute,
 * asynchronously, after the delay. If an id is specified, this timeout will override and
 * cancel any existing timeout with the same id. Any additional arguments will be passed
 * into callback when it is executed.
 * If the callback returns true, the timeout loop will execute again, after the delay,
 * creating a polling loop until the callback returns a non-true value.
 *
 * @param {string|number} idOrDelay - A unique identifier for this timeout or the delay if no ID is given.
 * @param {number|Function} delayOrCallback - A zero-or-greater delay in milliseconds or the callback function if no ID is given.
 * @param {Function} [callback] - A function to be executed after delay milliseconds.
 * @param {...any} args - Additional arguments to pass to the callback.
 * @returns {boolean | undefined} - If the callback is yet to be executed, true is returned, otherwise undefined.
 * @usage
 * // Initialize a timeout with an ID
 * doTimeout('myTimeout', 1000, () => console.log('Hello, world!'));
 * // Initialize a timeout without an ID
 * doTimeout(1000, () => console.log('Hello, world!'));
 * // Cancel a timeout with an ID
 * doTimeout('myTimeout');
 * // Force execution of a timeout with an ID
 * doTimeout('myTimeout', 0);
 * // Initialize a polling loop
 * // Example usage for polling
    doTimeout(100, function() {
        if (someCondition()) {
            console.log('Condition met, stopping the polling.');
            return false;  // Stop polling when some condition is true
        }
        console.log('Condition not met, continue polling.');
        return true;  // Continue polling by returning true
    });
 *  
 */
function doTimeout(idOrDelay, delayOrCallback, callback) {
  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }
  var id, delay;
  if (typeof idOrDelay === 'string' && typeof delayOrCallback === 'number') {
    id = idOrDelay;
    delay = delayOrCallback;
  } else if (typeof idOrDelay === 'number' && typeof delayOrCallback === 'function') {
    delay = idOrDelay;
    callback = delayOrCallback;
    args = [callback].concat(_toConsumableArray(args));
    id = undefined;
  }

  // Namespace for timeout IDs to prevent conflicts
  var namespace = '_doTimeout_';
  var fullId = id ? namespace + id : null;

  // Clear any existing timeout with this ID
  if (fullId && fullId in doTimeoutStore) {
    clearTimeout(doTimeoutStore[fullId]);
    delete doTimeoutStore[fullId];
  }

  // Clean up function to remove the timeout ID
  function cleanup() {
    if (fullId && fullId in doTimeoutStore) {
      delete doTimeoutStore[fullId];
    }
  }

  // Setup the actual timeout function
  function setupTimeout() {
    doTimeoutStore[fullId] = setTimeout(function () {
      if (callback.apply(void 0, _toConsumableArray(args)) === true) {
        setupTimeout();
      } else {
        cleanup();
      }
    }, delay);
  }

  // If callback is a function and delay is defined, set up the timeout
  if (typeof callback === 'function' && typeof delay === 'number') {
    setupTimeout();
    return true;
  }

  // Cancel the timeout without executing the callback
  if (id && delay === undefined) {
    cleanup();
  }
}

/**
 * Wraps a function that might be synchronous or asynchronous into a standardized asynchronous workflow.
 * @param {Function} fn - A function that may be synchronous or return a Promise.
 * @returns {Promise<any>} - A Promise resolving with the function's return value or rejecting with any thrown error.
 */
var doAsync = function doAsync(fn) {
  return new Promise( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {
      var fx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return fn();
          case 3:
            fx = _context3.sent;
            resolve(fx);
            _context3.next = 10;
            break;
          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            reject(_context3.t0);
          case 10:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[0, 7]]);
    }));
    return function (_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }());
};

/***/ }),

/***/ "../utility/src/proxyObject.js":
/*!*************************************!*\
  !*** ../utility/src/proxyObject.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ proxyObject),
/* harmony export */   proxyClass: () => (/* binding */ proxyClass),
/* harmony export */   proxyObject: () => (/* binding */ proxyObject)
/* harmony export */ });
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// [2023] [Knighttower] https://github.com/knighttower

/**
 * @module proxyObject
 * Convert to proxy to protect objects
 * Allows to declare _private, _protected and _mutable - all arrays with prop names
 * @example proxyObject({objectProps..., _protected: array(...)})
 * @param {Object} object
 * @return {Proxy}
 * @usage const proxy = proxyObject({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})
 * @usage _protected: array(...) -> Cannot be modified
 * @usage _private: array(...) -> Cannot be accessed
 * @usage _mutable: array(...) -> Can be modified
 */
function proxyObject(object) {
  'use strict';

  // Initialize property access control sets
  var _private = new Set(['_private'].concat(_toConsumableArray(object._private || [])));
  var _protected = new Set(['_protected'].concat(_toConsumableArray(_private), _toConsumableArray(object._protected || [])));
  var _mutable = new Set(object._mutable || []);
  var canMutate = function canMutate(prop) {
    if (_protected.has(prop) && !_mutable.has(prop)) {
      console.error("Attempt to modify protected property: ".concat(prop));
      return false;
    }
    if (_private.has(prop) && !_mutable.has(prop)) {
      console.error("Attempt to modify private property: ".concat(prop));
      return false;
    }
    return true;
  };
  return new Proxy(object, {
    get: function get(target, prop, receiver) {
      if (_private.has(prop)) {
        console.error("Attempt to access private property: ".concat(prop));
        return undefined;
      }
      return Reflect.get(target, prop, receiver);
    },
    set: function set(target, prop, value, receiver) {
      if (!canMutate(prop)) {
        return false;
      }
      return Reflect.set(target, prop, value, receiver);
    },
    deleteProperty: function deleteProperty(target, prop) {
      if (!canMutate(prop)) {
        return false;
      }
      return Reflect.deleteProperty(target, prop);
    },
    defineProperty: function defineProperty(target, prop, descriptor) {
      if (!canMutate(prop)) {
        return false;
      }
      return Reflect.defineProperty(target, prop, descriptor);
    },
    ownKeys: function ownKeys(target) {
      return Reflect.ownKeys(target).filter(function (key) {
        return !_private.has(key);
      });
    },
    enumerate: function enumerate(target) {
      var keys = Reflect.enumerate(target);
      return keys.filter(function (key) {
        return !_private.has(key);
      });
    },
    has: function has(target, prop) {
      return !_private.has(prop) && Reflect.has(target, prop);
    },
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {
      if (_private.has(prop)) {
        return undefined;
      }
      return Reflect.getOwnPropertyDescriptor(target, prop);
    }
  });
}

/**
 * Enhances a class with proxy functionality to enforce access and mutation rules for its properties.
 * This approach utilizes a higher-order function to wrap the class with a Proxy.
 */

/**
 * Wraps a class with a Proxy to enforce private, protected, and mutable properties.
 * @param {Function} BaseClass - The class to be wrapped.
 * @returns {Proxy} A proxy-wrapped class enforcing the specified access controls.
 * @usage
 * // Example class to use with proxyClass
    class MyClass {
        constructor() {
            this.publicProp = 'This can be accessed and modified.';
            this.protectedProp = 'This cannot be modified.';
            this.privateProp = 'This cannot be accessed or modified.';
            this.mutableProp = 'This can be modified.';
            this._protected = ['protectedProp'];
            this._private = ['privateProp'];
            this._mutable = ['mutableProp'];
        }
    }

    // Enhanced class with proxyClass
    const ProxyEnhancedMyClass = proxyClass(MyClass);

    // Example usage
    const instance = new ProxyEnhancedMyClass();
    console.log(instance.publicProp); // Accessible
    instance.publicProp = 'New value'; // Modifiable
    console.log(instance.privateProp); // Attempt to access private property: privateProp
    instance.mutableProp = 'Changed'; // Modifiable, even if protected
    console.log(instance.mutableProp);
    delete instance.privateProp;
 */
function proxyClass(BaseClass) {
  return new Proxy(BaseClass, {
    construct: function construct(target, args) {
      var instance = _construct(target, _toConsumableArray(args));
      return proxyObject(instance);
    }
  });
}


/***/ }),

/***/ "../utility/src/urlHelper.js":
/*!***********************************!*\
  !*** ../utility/src/urlHelper.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ urlHelper),
/* harmony export */   urlHelper: () => (/* binding */ urlHelper)
/* harmony export */ });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * URL Object Class with public methods for URL functions and manipulation.
 *
 * @module urlHelper
 */
var urlHelper = function urlHelper() {
  'use strict';

  /**
   * The window object from the global scope.
   * @type {Window}
   */
  var _LOCATION$protocol;
  var win = typeof window !== 'undefined' ? window : undefined;

  /**
   * The document object from the global scope.
   * @type {Document}
   */
  var doc = typeof document !== 'undefined' ? document : {};
  var LOCATION = win === null || win === void 0 ? void 0 : win.location;
  var hash = LOCATION === null || LOCATION === void 0 ? void 0 : LOCATION.hash;
  var HREF = LOCATION === null || LOCATION === void 0 ? void 0 : LOCATION.href;
  var SEARCH = LOCATION === null || LOCATION === void 0 ? void 0 : LOCATION.search;

  /**
   * Protocol part of the URL, without the colon.
   * @type {string}
   */
  var PROTOCOL = LOCATION === null || LOCATION === void 0 || (_LOCATION$protocol = LOCATION.protocol) === null || _LOCATION$protocol === void 0 ? void 0 : _LOCATION$protocol.replace(':', '');

  /**
   * Host part of the URL, including hostname and port.
   * @type {string}
   */
  var HOST = LOCATION === null || LOCATION === void 0 ? void 0 : LOCATION.host;

  /**
   * Pathname part of the URL.
   * @type {string}
   */
  var PATH = LOCATION === null || LOCATION === void 0 ? void 0 : LOCATION.pathname;

  /**
   * Base site URL, constructed from protocol and host.
   * @type {string}
   */
  var SITE_URL = "".concat(PROTOCOL, "://").concat(HOST);

  /**
   * Full URL constructed from protocol, host, and path.
   * @type {string}
   */
  var FULL_URL = "".concat(SITE_URL).concat(PATH);

  /**
   * Parses the current URL parameters and caches them for future use.
   * @returns {Object} Contains various representations of URL parameters.
   * @private
   */
  var parseURLParams = function parseURLParams() {
    if (cachedURLParams) {
      return cachedURLParams;
    }
    var params = new URLSearchParams(SEARCH);
    var vars = {};
    var _iterator = _createForOfIteratorHelper(params.entries()),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          key = _step$value[0],
          value = _step$value[1];
        vars[key] = value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    cachedURLParams = {
      params: params,
      queryString: params.toString(),
      search: SEARCH,
      keys: Array.from(params.keys()),
      values: Array.from(params.values()),
      collection: vars
    };
    return cachedURLParams;
  };

  /**
   * Cached URL parameters for efficient access.
   * @type {Object|null}
   */
  var cachedURLParams = null;

  /**
   * Public methods and properties for URL manipulation and information.
   * @namespace
   */
  return {
    /**
     * Retrieves the current page name (last part of the URL).
     * @return {string} The current page name or 'index' if none is found.
     */
    getPage: function getPage() {
      var _HREF;
      var cURL = (_HREF = HREF) === null || _HREF === void 0 ? void 0 : _HREF.toLowerCase();
      var page = cURL.split('/').pop().split('.')[0];
      return page || 'index';
    },
    /**
     * Retrieves parsed URL parameters.
     * @return {Object} An object with methods and properties to interact with URL parameters.
     */
    getParams: function getParams() {
      return parseURLParams();
    },
    /**
     * Retrieves the URL's query string.
     * @return {string} The query string of the current URL.
     */
    getQuery: function getQuery() {
      return parseURLParams().queryString;
    },
    /**
     * Adds new parameters to the current URL's query string.
     * @param {Object} query The new parameters to add.
     * @return {Object} An object containing the updated query parameters and string.
     */
    addToQuery: function addToQuery(query) {
      var currentQuery = parseURLParams().collection;
      Object.assign(currentQuery, query);
      var qString = Object.entries(currentQuery).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
      }).join('&');
      return {
        collection: currentQuery,
        queryString: qString
      };
    },
    /**
     * Retrieves the hash part of the URL, without the '#' symbol.
     * @return {string} The current hash value.
     */
    getHash: function getHash() {
      var _hash;
      return (_hash = hash) === null || _hash === void 0 ? void 0 : _hash.substring(1);
    },
    /**
     * Sets the hash part of the URL.
     * @param {string} h The hash to set.
     */
    setHash: function setHash(h) {
      hash = h;
    },
    /**
     * Removes the hash part of the URL.
     */
    deleteHash: function deleteHash() {
      history.pushState('', doc.title, PATH + SEARCH);
    },
    /**
     * Navigates to a specified URL.
     * @param {string} url The URL to navigate to.
     * @return {boolean} Always returns false to prevent default browser behavior.
     */
    goTo: function goTo(url) {
      HREF = url;
      return false;
    },
    /**
     * Opens a URL in a new window or tab.
     * @param {string} url The URL to open.
     * @param {string} [name='_blank'] The target window name.
     * @param {string} [params=''] Parameters for the new window.
     * @return {Window} The window object of the newly opened window.
     */
    open: function open(url) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_blank';
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      return win.open(url, name, params);
    },
    /**
     * Sets up a listener to execute a callback function when the URL hash changes.
     * @param {Function} callback The function to call when the hash changes.
     */
    onChange: function onChange(callback) {
      if (typeof callback === 'function') {
        win.addEventListener('hashchange', callback);
      }
    },
    // Exposing constants for easy access
    fullUrl: FULL_URL,
    siteUrl: SITE_URL,
    protocol: PROTOCOL,
    host: HOST,
    path: PATH,
    readUrl: HREF
  };
};


/***/ }),

/***/ "../utility/src/utility.js":
/*!*********************************!*\
  !*** ../utility/src/utility.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertToBool: () => (/* binding */ convertToBool),
/* harmony export */   convertToNumber: () => (/* binding */ convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* binding */ currencyToDecimal),
/* harmony export */   dateFormat: () => (/* binding */ dateFormat),
/* harmony export */   decimalToCurrency: () => (/* binding */ decimalToCurrency),
/* harmony export */   emptyOrValue: () => (/* binding */ emptyOrValue),
/* harmony export */   formatPhoneNumber: () => (/* binding */ formatPhoneNumber),
/* harmony export */   getDynamicId: () => (/* binding */ getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* binding */ getGoogleMapsAddress),
/* harmony export */   getRandomId: () => (/* binding */ getRandomId),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   instanceOf: () => (/* binding */ instanceOf),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   makeArray: () => (/* binding */ makeArray),
/* harmony export */   openGoogleMapsAddress: () => (/* binding */ openGoogleMapsAddress),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   toCurrency: () => (/* binding */ toCurrency),
/* harmony export */   toDollarString: () => (/* binding */ toDollarString),
/* harmony export */   typeOf: () => (/* binding */ typeOf),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   validateEmail: () => (/* binding */ validateEmail),
/* harmony export */   validatePhone: () => (/* binding */ validatePhone)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------

// -----------------------------
// METHODS
// -----------------------------

/**
 * Convert a value to bool
 * @param {String|Boolean|Int|Number} val
 * @return {Boolean}
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 * @usage convertToBool('0') // false
 * @usage convertToBool('1') // true
 * @usage convertToBool('') // false
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 */
function convertToBool(val) {
  switch (_typeof(val)) {
    case 'boolean':
      return val;
    case 'string':
      return val === 'false' || val === '0' ? false : true;
    case 'number':
      return val !== 0;
    default:
      return Boolean(val);
  }
}

/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
  var isNum = isNumber(input);
  if (isNum !== null) {
    return isNum;
  }
  // Case: String that cannot be converted to a number
  return input;
}

/**
 * Translate dollar amounts to decimal notation
 * @function currencyToDecimal
 * @memberof utility
 * @param {String|Number} amount
 * @return number
 * @example currencyToDecimal('$123.45') // 123.45
 */
function currencyToDecimal(amount) {
  return Number(amount.replace(/[^0-9.-]+/g, ''));
}

/**
 * Format dates to standard US, with or w/out time
 * @function dateFormat
 * @memberof utility
 * @param {String} dateTime Raw format 2201-01-01 16:15PM or unix or object
 * @param {Boolean} wTime If set, returns date with time as H:MM A
 * @return string
 * @example dateFormat('2201-01-01 16:15PM') // 01/01/2201
 * @example dateFormat('2201-01-01 16:15PM', true) // 01/01/2201 @ 4:15 PM
 * @example dateFormat('2201-01-01 16:15PM', false) // 01/01/2201
 * @example dateFormat('2201-01-01') // 01/01/2201
 */
function dateFormat(dateTime, wTime) {
  if (!dateTime || isNaN(new Date(dateTime).getTime())) {
    return null;
  }
  var date = new Date(dateTime);

  // Ensuring that the time zone is taken into account.
  var optionsDate = {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    timeZone: 'UTC'
  };
  var formattedDate = new Intl.DateTimeFormat('en-US', optionsDate).format(date);
  if (wTime) {
    var optionsTime = {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true,
      timeZone: 'UTC'
    };
    var formattedTime = new Intl.DateTimeFormat('en-US', optionsTime).format(date);
    return "".concat(formattedDate, " @ ").concat(formattedTime);
  }
  return formattedDate;
}

/**
 * Translate decimal notation to dollar amount
 * @function decimalToCurrency
 * @memberof utility
 * @param {String|Number} amount
 * @return number
 * @example decimalToCurrency(123.45) // 123.45
 * @example decimalToCurrency(2123.46) // 2,123.46
 */
function decimalToCurrency(amount) {
  var formatConfig = {
    minimumFractionDigits: 2
  };
  return new Intl.NumberFormat('en-GB', formatConfig).format(amount);
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value) {
  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  /**
   * Test sequence:
   * If it is a number 0> : true
   * If is not undefined: true
   * If it is boolean (true|false) prevents going to empty
   * If it is not Empty, [], null, {}, 0, true, false: true
   */

  if (isNumber(value) !== null || typeof value === 'boolean') {
    return value;
  } else if (!isEmpty(value)) {
    return value;
  }
  return _default;
}

/**
 * Format a phone number based on a given template.
 * @param {string} phoneNumber - The phone number to format.
 * @param {string} template - The template to use for formatting.
 * @returns {string} - The formatted phone number.
 * @example console.log(formatPhoneNumber('1234567890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('1234567890', '000-000-0000')); // Output: 123-456-7890
 * @example console.log(formatPhoneNumber('123-456-7890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('(123) 456-7890', '000-0000-0000')); // Output: 123-4567-890
 */
function formatPhoneNumber(phoneNumber, template) {
  // Remove all non-numeric characters from the phone number
  var cleaned = phoneNumber.replace(/\D/g, '');

  // Verify the length of the cleaned phone number
  if (cleaned.length !== 10) {
    throw new Error('Invalid phone number length');
  }

  // Initialize an array to hold the formatted phone number
  var formatted = [];

  // Initialize a pointer for the cleaned phone number
  var cleanedPointer = 0;

  // Loop through the template and replace placeholders with actual numbers
  for (var i = 0; i < template.length; i++) {
    if (template[i] === '0') {
      formatted.push(cleaned[cleanedPointer]);
      cleanedPointer++;
    } else {
      formatted.push(template[i]);
    }
  }
  return formatted.join('');
}

/**
 * Make sure the the item is an array or convert it to an array
 * @function makeArray
 * @param {String|Array} item
 * @return array
 * @example makeArray('test') // ['test']
 */
var makeArray = function makeArray(item) {
  return Array.isArray(item) ? item : [item];
};

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
  return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
var getRandomId = getDynamicId;
var randomId = getDynamicId;
var uuid = function uuid() {
  var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
  var rnd = function rnd() {
    return Math.random().toString(36).substring(2, 15);
  };
  max = max || 40;
  var str = '';
  for (var i = 0; i < max / 3 + 1; i++) {
    str += rnd();
  }
  return str.substring(0, max);
};
var uniqueId = uuid;

/**
 * Form a valid Google search address
 * @function getGoogleMapsAddress
 * @memberof utility
 * @param {String|Object} address
 * @return string
 * @example getGoogleMapsAddress('New York') // 'https://maps.google.it/maps?q=New+York'
 * @example getGoogleMapsAddress({ address: 'New York', zip: '10001' }) // 'https://maps.google.it/maps?q=New+York+10001'
 * @example getGoogleMapsAddress({ address: 'New York', city: 'New York', state: 'NY' }) // 'https://maps.google.it/maps?q=New+York+New+York+NY'
 */
function getGoogleMapsAddress(address) {
  if (!address) {
    return false;
  }
  var search = '';
  if (typeOf(address, 'string')) {
    search = address;
  } else {
    var keys = ['address', 'address1', 'city', 'state', 'zip', 'zipcode'];
    search = keys.reduce(function (acc, key) {
      var value = Object.keys(address).find(function (aKey) {
        return aKey.includes(key) && address[aKey];
      });
      return value ? "".concat(acc, " ").concat(address[value]) : acc;
    }, '');
  }
  search = search.trim().replace(/\s+|,/g, '+');
  return "https://maps.google.it/maps?q=".concat(search);
}

/**
 * Check if a value is in a collection (array, string, object)
 * @param {collection} collection - The collection to search in
 * @param {value} value - The value to search for
 * @param {fromIndex} fromIndex - The index to start searching from
 * @return {boolean} - True if the value is in the collection, false otherwise
 */
function includes(collection, value) {
  var fromIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (Array.isArray(collection) || typeof collection === 'string') {
    // Use native includes for arrays and strings
    return collection.includes(value, fromIndex);
  }
  if (_typeof(collection) === 'object') {
    // Search in object values
    for (var key in collection) {
      if (collection[key] === value) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
  if (value === null || value === undefined) {
    return true;
  }
  if (typeof value === 'string' || Array.isArray(value)) {
    return value.length === 0;
  }
  if (value instanceof Map || value instanceof Set) {
    return value.size === 0;
  }
  if (ArrayBuffer.isView(value)) {
    return value.byteLength === 0;
  }
  if (_typeof(value) === 'object') {
    return Object.keys(value).length === 0;
  }
  return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
  var isType = _typeof(value);
  switch (value) {
    case null:
    case undefined:
    case '':
      return null;
    case '0':
    case 0:
      return 0;
    default:
      if (isType === 'number' || isType === 'string') {
        if (typeof value === 'number' || !Number.isNaN(Number(value))) {
          return +value;
        }
      }
      break;
  }
  return null;
}

/**
 * Check the instance of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string|instance} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable or boolean when test is provided
 */
function instanceOf(input, test) {
  var inputType = 'unknown';
  var isValid = typeof input === 'function' || _typeof(input) === 'object';
  if (input === null || !isValid) {
    return false;
  }
  var instanceMapping = [Date, RegExp, Promise, Map, Set, WeakMap, WeakSet, ArrayBuffer, DataView];
  var instTotal = instanceMapping.length;
  while (instTotal--) {
    if (input instanceof instanceMapping[instTotal]) {
      inputType = instanceMapping[instTotal].name;
      break;
    }
  }
  if (test) {
    test = typeof test === 'string' ? test.toLowerCase() : test.name.toLowerCase();
    // In case that the input is a custom instance
    if (inputType === 'unknown') {
      inputType = input.name;
    }
    return test === inputType.toLowerCase();
  }
  return inputType;
}

/**
 * Open a Google Map using a provided address
 * @function openGoogleMapsAddress
 * @memberof utility
 * @param {String|Object} object - Address information either as a string or as an object
 * @throws {Error} Throws an error if the address is invalid or if it's not a string or object.
 * @return {void}
 * @example openGoogleMapsAddress('New York'); // Opens Google Maps with the address 'New York'
 * @example openGoogleMapsAddress({ address: 'New York', zip: '10001' }); // Opens Google Maps with the address 'New York 10001'
 */
function openGoogleMapsAddress(object) {
  if (!typeOf(object, 'string') || !typeOf(object, 'object')) {
    throw new Error('The input must be a string or an object.');
  }
  var address = getGoogleMapsAddress(object);
  if (!isEmpty(address) || !typeOf(address, 'string')) {
    throw new Error('The address you are trying to open is invalid.');
  }
  return window.open(address, '_blank');
}

/**
 * Alias to getDynamicId
 * @function toCurrency
 * @memberof utility
 * @param {String|Number} amount
 * @return number
 * @example toCurrency(123.45) // 123.45
 * @example toCurrency(2123.46) // 2,123.46
 */
function toCurrency(amount) {
  return decimalToCurrency(amount);
}

/**
 * Covert to dollar string
 * @function toDollarString
 * @memberof utility
 * @param {String|Number} amount
 * @return number
 * @example toDollarString(2,000) // 2K
 * @example toDollarString(2,000,000) // 2M
 * @example toDollarString(2,500,000) // 2.5M
 */
function toDollarString(amount) {
  if (typeOf(amount, 'string')) {
    amount = currencyToDecimal(amount);
  }
  if (Math.abs(amount) > 999 && Math.abs(amount) < 999999) {
    return Math.sign(amount) * (Math.abs(amount) / 1000).toFixed(1) + 'K';
  }
  if (Math.abs(amount) > 999999) {
    return Math.sign(amount) * (Math.abs(amount) / 1000000).toFixed(1) + 'M';
  }
  return Math.sign(amount) * Math.abs(amount);
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
  // Special case for null since it can be treated as an object
  if (input === null) {
    if (test) {
      return test === null || test === 'null' ? true : false;
    }
    return 'null';
  }
  var inputType;
  switch (_typeof(input)) {
    case 'number':
    case 'string':
    case 'boolean':
    case 'undefined':
    case 'bigint':
    case 'symbol':
    case 'function':
      inputType = _typeof(input);
      break;
    case 'object':
      inputType = Array.isArray(input) ? 'array' : 'object';
      break;
    default:
      inputType = 'unknown';
  }
  if (test) {
    if (test.includes('|')) {
      var _iterator = _createForOfIteratorHelper(test.split('|')),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var type = _step.value;
          if (inputType === type) {
            return type;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return false;
    }
    return test === inputType;
  }
  return inputType;
}

/**
 * Validate emails
 * @function validateEmail
 * @memberof utility
 * @param {String} email
 * @return Boolean
 * @example validateEmail('<EMAIL>') // false
 * @example validateEmail('test@test') // false
 * @example validateEmail('test@test.') // false
 * @example validateEmail('test@test.c') // false
 * @example validateEmail('test@test.com') // true
 */
function validateEmail(email) {
  var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
  return emailRegex.test(email);
}

/**
 * Validate a phone number
 * @function validatePhone
 * @memberof utility
 * @param {String} phone
 * @return void|Toast
 * @example validatePhone('1234567890') // true
 * @example validatePhone('(123) 456-7890') // true
 * @example validatePhone('123-456-7890') // true
 * @example validatePhone('123 456 7890') // false
 * @example validatePhone('123-4567-89') // false
 */
function validatePhone(phone) {
  var phoneRegex = /^\(?(\d{3})\)?[- ]?(\d{3})[- ]?(\d{4})$/;
  return phoneRegex.test(phone);
}

// //   utility; {
//     convertToBool,
//     currencyToDecimal,
//     convertToNumber,
//     dateFormat,
//     decimalToCurrency,
//     emptyOrValue,
//     formatPhoneNumber,
//     getDynamicId,
//     getGoogleMapsAddress,
//     getRandomId,
//     includes,
//     isEmpty, // from https://moderndash.io/
//     isNumber,
//     instanceOf,
//     openGoogleMapsAddress,
//     toCurrency,
//     toDollarString,
//     typeOf,
//     validateEmail,
//     validatePhone,
//     makeArray,
//     uuid,
//     uniqueId,
// };

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************!*\
  !*** ./examples/react/app.js ***!
  \*******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var Adaptive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Adaptive.js */ "./src/Adaptive.js");
/* harmony import */ var _hello_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hello.jsx */ "./examples/react/hello.jsx");
/**
* @author Knighttower
    MIT License

    Copyright (c) [2022] [Knighttower] https://github.com/knighttower

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
// We are using the React tag, but when using import...
// import React from 'react';
// import ReactDom from 'react-dom';

// When, in actual use, this should be: import Adaptive from 'Adaptive';

//Optional | Add custom media query (min px, max px) settings (min max)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].addQueryMinMax('kitty', 900, 1400);
// Optional | Add a custom media query expression (it accepts any valid media query)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].addQueryExpression('doggy', '(min-width: 900px)');
// Register react object and use in Hybrid mode (default is false)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].useReact(React, true);

// Do components and other stuff right after

Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].init();
})();

/******/ })()
;