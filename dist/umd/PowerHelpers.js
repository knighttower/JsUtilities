/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("PowerHelpers", [], factory);
	else if(typeof exports === 'object')
		exports["PowerHelpers"] = factory();
	else
		root["PowerHelpers"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/DomObserver.js":
/*!****************************!*\
  !*** ./src/DomObserver.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Author Knighttower\n// MIT License\n// [2022] [Knighttower] https://github.com/knighttower\n/**\n * @module DomObserver\n * Detect DOM changes\n * @name DomObserver\n * @param {window} selector\n * @param {Function}\n * @return DomObserver\n * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })\n * @example DomObserver.removeOnNodeChange('elementIdentifier')\n */\n/**\n * Holds memory of registered functions\n * @private\n */\nconst executeOnNodeChanged = {};\n/**\n * When node change\n * @param {String} id\n * @param {Function} callback Callback when any node changes/ add/deleted/modified\n * @return {Void}\n */\nconst addOnNodeChange = (id, callback) => {\n    if (callback) {\n        executeOnNodeChanged[id] = callback;\n    }\n};\n/**\n * Remove from node change\n * @param {String} id\n * @return {Void}\n */\nconst removeOnNodeChange = (id) => {\n    if (id) {\n        delete executeOnNodeChanged[id];\n    }\n};\n/**\n * Deep cleanup\n * @return {Void}\n */\nconst cleanup = () => {\n    Object.keys(executeOnNodeChanged).forEach((key) => delete executeOnNodeChanged[key]);\n};\n/**\n * Observer\n * @private\n * @return {MutationObserver}\n */\n(() => {\n    if (typeof window !== 'undefined') {\n        const callback = (mutationList, observer) => {\n            for (const mutation of mutationList) {\n                if (mutation.type === 'childList') {\n                    for (const id in executeOnNodeChanged) {\n                        executeOnNodeChanged[id]();\n                    }\n                }\n            }\n        };\n        const config = {\n            childList: true,\n            subtree: true,\n        };\n        const observer = new MutationObserver(callback);\n        observer.observe(document.body, config);\n    }\n})();\nconst DomObserver = {\n    executeOnNodeChanged,\n    addOnNodeChange,\n    removeOnNodeChange,\n    cleanup,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DomObserver);\n\n\n//# sourceURL=webpack://PowerHelpers/./src/DomObserver.js?");

/***/ }),

/***/ "./src/ElementHelper.js":
/*!******************************!*\
  !*** ./src/ElementHelper.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _DomObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DomObserver */ \"./src/DomObserver.js\");\n// Author Knighttower\n// MIT License\n// Copyright (c) [2022] [Knighttower] https://github.com/knighttower\n\n\n\n/**\n * @class Adds some extra functionality to interact with a DOM element\n * @param {String|Object} selector Class or ID or DOM element\n * @param {String} scope The scope to search in, window, document, dom element. Defaults to document\n * @return {Object}\n * @example new ElementHelper('elementSelector')\n * @example new ElementHelper('elementSelector', domElement|window|document)\n *\n */\nclass ElementHelper {\n    /**\n     * Constructor\n     * @param {String|Object} selector\n     * @return {Object}\n     */\n    constructor(selector, scope = document) {\n        this.selector = selector;\n        if (typeof selector === 'object') {\n            this.domElement = selector;\n        } else if (String(selector).includes('//')) {\n            this.domElement = this.getElementByXpath(selector);\n        } else {\n            this.domElement = scope.querySelector(selector);\n        }\n    }\n\n    // =========================================\n    // --> Public\n    // --------------------------\n\n    /**\n     * Check if the element exists or is visible. It will keep querying\n     * @return {Boolean}\n     */\n    isInDom() {\n        return Boolean(this.domElement?.outerHTML);\n    }\n\n    /**\n     * Wait for element exists or is visible. It will keep querying\n     * @function whenInDom\n     * @return {Promise}\n     */\n    whenInDom() {\n        let $this = this;\n        let callbackId = Date.now() + Math.floor(Math.random() * 1000);\n\n        return new Promise(function (resolveThis) {\n            if (!$this.isInDom()) {\n                _DomObserver__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addOnNodeChange(callbackId, () => {\n                    let element = new ElementHelper($this.selector);\n                    if (element.isInDom()) {\n                        $this = element;\n                        resolveThis($this);\n                        _DomObserver__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeOnNodeChange(callbackId);\n                    }\n                });\n            } else {\n                resolveThis($this);\n            }\n        });\n    }\n\n    /**\n     * Find element by Xpath string\n     * @param {String} xpath\n     * @example getElementByXpath(\"//html[1]/body[1]/div[1]\")\n     * @return {Object} DOM element\n     */\n    getElementByXpath(xpath) {\n        return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n    }\n\n    /**\n     * Get the element xpath string\n     * @author Based on https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reload-to-the-same-place-even-if/2631931#2631931\n     * @return {String}\n     */\n    getXpathTo() {\n        let element = this.domElement;\n\n        if (element.id) {\n            return \"//*[@id='\" + element.id + \"']\";\n        }\n        if (element === document.body) {\n            return '//' + element.tagName;\n        }\n\n        let ix = 0;\n        let siblings = element.parentNode.childNodes;\n        for (let i = 0; i < siblings.length; i++) {\n            let sibling = siblings[i];\n            if (sibling === element) {\n                return (\n                    new ElementHelper(element.parentNode).getXpathTo() + '/' + element.tagName + '[' + (ix + 1) + ']'\n                );\n            }\n            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {\n                ix++;\n            }\n        }\n    }\n\n    /**\n     * Get the element attribute, but parse it if it is an object or array\n     * @param {String} attr Atrribute name\n     * @return {String|Array|Object|Null}\n     */\n    getAttribute(attr) {\n        return this.domElement.getAttribute(attr) || null;\n    }\n\n    /**\n     * Create a unique has for the element derived from its xpath\n     * @author Based on https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/\n     * @return {String}\n     */\n    getHash() {\n        let string = String(this.getXpathTo());\n        let hash = 0;\n\n        if (string.length === 0) {\n            return hash;\n        }\n\n        for (let i = 0; i < string.length; i++) {\n            let char = string.charCodeAt(i);\n            hash = (hash << 5) - hash + char;\n            hash = hash & hash;\n        }\n\n        return hash;\n    }\n}\n\n/**\n * Future\n * @private\n * @todo enhance to extend the prototype like https://stackoverflow.com/questions/779880/in-javascript-can-you-extend-the-dom\n */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ElementHelper);\n\n\n//# sourceURL=webpack://PowerHelpers/./src/ElementHelper.js?");

/***/ }),

/***/ "./src/PowerHelpers.js":
/*!*****************************!*\
  !*** ./src/PowerHelpers.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PowerHelper: () => (/* binding */ powerHelper),\n/* harmony export */   addQuotes: () => (/* binding */ addQuotes),\n/* harmony export */   cleanStr: () => (/* binding */ cleanStr),\n/* harmony export */   convertKeysToSymbols: () => (/* binding */ convertKeysToSymbols),\n/* harmony export */   \"default\": () => (/* binding */ powerHelper),\n/* harmony export */   findAndReplaceInArray: () => (/* binding */ findAndReplaceInArray),\n/* harmony export */   findNested: () => (/* binding */ findNested),\n/* harmony export */   fixQuotes: () => (/* binding */ fixQuotes),\n/* harmony export */   getArrObjFromString: () => (/* binding */ getArrObjFromString),\n/* harmony export */   getChunks: () => (/* binding */ getChunks),\n/* harmony export */   getDirectivesFromString: () => (/* binding */ getDirectivesFromString),\n/* harmony export */   getMatchBlock: () => (/* binding */ getMatchBlock),\n/* harmony export */   getMatchInBetween: () => (/* binding */ getMatchInBetween),\n/* harmony export */   powerHelper: () => (/* binding */ powerHelper),\n/* harmony export */   removeQuotes: () => (/* binding */ removeQuotes),\n/* harmony export */   setExpString: () => (/* binding */ setExpString),\n/* harmony export */   setLookUpExp: () => (/* binding */ setLookUpExp),\n/* harmony export */   setWildCardString: () => (/* binding */ setWildCardString),\n/* harmony export */   startAndEndWith: () => (/* binding */ startAndEndWith),\n/* harmony export */   wildCardStringSearch: () => (/* binding */ wildCardStringSearch)\n/* harmony export */ });\n/* harmony import */ var _Utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility */ \"./src/Utility.js\");\n// Author Knighttower\n// MIT License\n// Copyright (c) [2022] [Knighttower] https://github.com/knighttower\n\n\n\n// @private\nfunction _removeBrackets(strExp) {\n    const regex = /^(\\[|\\{)(.*?)(\\]|\\})$/; // Match brackets at start and end\n    const match = strExp.match(regex);\n\n    if (match) {\n        return match[2].trim(); // Extract and trim the content between brackets\n    }\n\n    return strExp; // Return the original string if no brackets found at start and end\n}\n\n/**\n * Add quotes to a string\n * @function addQuotes\n * @param {String} str\n * @return {String}\n * @example addQuotes('hello') // \"hello\"\n */\nfunction addQuotes(str, q = '\"') {\n    return `${q}${str}${q}`;\n}\n\n/**\n * Clean a string from delimeters or just trimmed if no delimeters given\n * @funtion cleanStr\n * @param {String} str - String to use\n * @param {String|Regex} p1 - Delimeter 1\n * @param {String|Regex} p2 - Delimeter 2\n * @return {String|void}\n * @example cleanStr('hello world', 'h', 'd') // 'ello worl'\n * @example cleanStr('  hello world  ') // 'hello world'\n * @example cleanStr('hello world', 'hello') // 'world'\n * @example cleanStr('Hello World. Sunshine is here!', '\\..*!') // Hello World\n * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'\n * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'\n */\nfunction cleanStr(str, ...args) {\n    if (!str) return;\n    if (typeof str !== 'string') return str;\n\n    return args\n        .reduce((accStr, arg) => {\n            const regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));\n            return accStr.replace(regex, '');\n        }, str)\n        .trim();\n}\n\n/**\n * convert all keys from an object to symbols\n * @function convertKeysToSymbols\n * @param {object} obj - The object to convert\n * @return {object} - The object with all keys converted to symbols\n * @example convertKeysToSymbols({a: 1, b: 2}) // returns {Symbol(a): 1, Symbol(b): 2, keyToSymbolMap: {a: Symbol(a), b: Symbol(b)}\n */\nfunction convertKeysToSymbols(obj) {\n    if ((0,_Utility__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(obj, null) === null) {\n        return {};\n    }\n    const newObj = {};\n    const keyToSymbolMap = {};\n    for (const key in obj) {\n        const symbolKey = Symbol(key);\n        newObj[symbolKey] = obj[key];\n        keyToSymbolMap[key] = symbolKey;\n    }\n    newObj.keyToSymbolMap = keyToSymbolMap;\n    return newObj;\n}\n\n/**\n * Recursively will loop in array to find the desired target\n * @function findAndReplaceInArray\n * @param {Array} arr\n * @param {String} find The target (needle)\n * @param {Array|Object|String} value Replacer\n * @return {Null|Array}\n * @example findAndReplaceInArray([1,2,3,4,5], 3, 'three') // [1,2,'three',4,5]\n */\nfunction findAndReplaceInArray(arr, find, value) {\n    let replaced = false;\n\n    const result = arr.map((prop) => {\n        if (Array.isArray(prop)) {\n            const replacedArray = findAndReplaceInArray(prop, find, value);\n            if (replacedArray) {\n                replaced = true;\n                return replacedArray;\n            }\n            return prop;\n        }\n        if (prop === find) {\n            replaced = true;\n            if (Array.isArray(value)) {\n                return value.map((p) => (Array.isArray(p) ? p : p.trim()));\n            }\n            return value;\n        }\n        return prop;\n    });\n\n    return replaced ? result : null;\n}\n\n/**\n * Find the last instance of nested pattern with delimeters\n * @function findNested\n * @param {string} str\n * @param {string} start - Delimeter 1\n * @param {string} end - Delimeter 2\n * @return {string|null}\n * @example findNested('[[]hello [world]]', '[', ']') // [world]\n */\nfunction findNested(str, start = '[', end = ']') {\n    if (typeof str !== 'string') return str;\n    // Find the last index of '['\n    const lastIndex = str.lastIndexOf(start);\n    // If '[' is not found, return null or some default value\n    if (lastIndex === -1) {\n        return null;\n    }\n\n    // Extract the substring starting from the last '[' to the end\n    const substring = str.substring(lastIndex);\n    // Find the index of the first ']' in the substring\n    const endIndex = substring.indexOf(end);\n    // If ']' is not found, return null or some default value\n    if (endIndex === -1) {\n        return null;\n    }\n    // Extract and return the content between the last '[' and the next ']', including them\n    return substring.substring(0, endIndex + 1);\n}\n\n/**\n * Fix quotes from a string\n * @function fixQuotes\n * @param {String} str\n * @return {String} q quote type\n * @return {String}\n * @example fixQuotes(\"'hello'\") // \"hello\"\n * @example fixQuotes('\"hello\"') // \"hello\"\n */\nfunction fixQuotes(str, q = '\"') {\n    if (typeof str !== 'string') return str;\n    return str.replace(/\\`|'|\"/g, q);\n}\n\n/**\n * Converts strings formats into objects or arrays\n * Note: quoted strings are not supported, use getDirectiveFromString instead\n * @param {string} strExp\n * @return {object|array|string}\n * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']\n * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']\n * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }\n */\nfunction getArrObjFromString(strExp) {\n    // alredy typeof object or array just return it\n    if ((0,_Utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(strExp, 'object') || (0,_Utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(strExp, 'array')) return strExp;\n    const isObject = startAndEndWith(strExp, '{', '}');\n    const isArray = startAndEndWith(strExp, '[', ']');\n    // If it is other type of string, return it\n    if (!isObject && !isArray) return strExp;\n\n    const newCollection = isObject ? {} : [];\n    const nestedElements = {};\n\n    //remove the brackets\n    let newStrExp = _removeBrackets(strExp);\n\n    const loopNested = (objects = false) => {\n        while (true) {\n            //find any nested arrays or objects\n            let matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);\n\n            if (!matched) break;\n\n            //replace the nested array or object with a marker so that we can safely split the string\n            let marker = `__${(0,_Utility__WEBPACK_IMPORTED_MODULE_0__.getRandomId)()}__`;\n            nestedElements[marker] = matched;\n\n            newStrExp = newStrExp.replace(matched, marker);\n        }\n    };\n\n    loopNested();\n    loopNested(true);\n\n    getChunks(newStrExp).forEach((chunk, index) => {\n        const isObjectKey = chunk.includes(':') && isObject;\n        const chunkParts = isObjectKey ? getChunks(chunk, ':') : [];\n        const chunkKey = removeQuotes((0,_Utility__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(chunkParts[0], index));\n        chunk = isObjectKey ? chunkParts[1] : chunk;\n        if (chunk in nestedElements) {\n            chunk = getArrObjFromString(nestedElements[chunk]);\n        }\n        chunk = (0,_Utility__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(removeQuotes(chunk));\n        // set back in the collection either as an object or array\n        isObject ? (newCollection[chunkKey] = chunk) : newCollection.push(chunk);\n    });\n    // uncomment to debug\n    // console.log('___ log ___', newCollection);\n    return newCollection;\n}\n\n/**\n * handles the following patterns to get an object from string attributes\n * // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}\n * // Matches the Array as string: [value, value] OR ['value','value']\n * // Matches a multi-array string like [[value,value]],value]\n * // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)\n * // Matches string ID or class: literals Id(#) or class (.). Note that in Vue it needs to be in quotes attr=\"'#theId'\"\n * // Mathes simple directive function style: directive(#idOr.Class)\n * Note: all the above with the exception of the Id/class will be converted into actual objects\n */\n/**\n * Converts strings formats into objects\n * @function getDirectivesFromString\n * @param {String|Array|Object} stringDirective\n * @return {object|null|void}\n * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}\n * @example getDirectivesFromString('[[value,value],value]') // {directive: 'values', directive2: 'values'}\n * @example getDirectivesFromString('directive.tablet|mobile(...values)') // {directive: {tablet: 'values', mobile: 'values'}}\n * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}\n */\nfunction getDirectivesFromString(stringDirective) {\n    const str = stringDirective;\n    if (!(0,_Utility__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(str)) return null;\n\n    const results = (type = null, results = null) => {\n        return {\n            type: type,\n            directive: results,\n        };\n    };\n    const matchArrayTypes = /^\\[((.|\\n)*?)\\]$/gm;\n    const matchObjectTypes = /^\\{((.|\\n)*?)\\:((.|\\n)*?)\\}/gm;\n    const matchFunctionString = /^([a-zA-Z]+)(\\()(\\.|\\#)(.*)(\\))/g;\n    const regexDotObjectString = /([a-zA-Z]+)\\.(.*?)\\(((.|\\n)*?)\\)/gm;\n    const regexExObjectString = /([a-zA-Z]+)\\[((.|\\n)*?)\\]\\(((.|\\n)*?)\\)/gm;\n    let type = typeof str;\n\n    if (type === 'object' || type === 'array') {\n        return results(type, str);\n    } else {\n        switch (true) {\n            case !!str.match(matchArrayTypes):\n                // Matches the Array as string: [value, value] OR ['value','value']\n                // regexArrayLike = /^\\[((.|\\n)*?)\\]$/gm;\n                // Matches a multi-array string like [[value,value]],value]\n                // regexMultiArrayString = /\\[(\\n|)(((.|\\[)*)?)\\](\\,\\n|)(((.|\\])*)?)(\\n|)\\]/gm;\n\n                type = 'array';\n                break;\n            case !!str.match(matchObjectTypes):\n                // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}\n                // regexObjectLike = /^\\{((.|\\n)*?)\\:((.|\\n)*?)\\}/gm;\n                type = 'object';\n                break;\n            case !!str.match(matchFunctionString):\n                // Mathes simple directive function style: directive(#idOr.Class)\n                // regexFunctionString\n                const directive = str.split('(')[0].trim();\n                return results('idOrClassWithDirective', { [directive]: getMatchInBetween(str, '(', ')') });\n            case !!str.match(regexDotObjectString):\n                // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)\n                // OR directive.breakdown|breakdown2(...values) OR directive.tablet(...values)&&directive.mobile(...values)\n                type = 'dotObject';\n                break;\n            case !!str.match(regexExObjectString):\n                type = 'dotObject';\n                break;\n\n            default:\n                return results('string', str);\n                break;\n        }\n    }\n\n    if (type === 'array' || type === 'object') {\n        let strQ = fixQuotes(str);\n        try {\n            return results(type, JSON.parse(strQ));\n        } catch (error) {\n            // uncomment to debug\n            // console.log('___ parse error ___', error);\n        }\n\n        return results(type, getArrObjFromString(strQ));\n    }\n\n    if (type === 'dotObject') {\n        let values, breakDownId, directive;\n        const setObject = {};\n\n        getChunks(str, '&&').forEach((command) => {\n            if (command.match(regexExObjectString)) {\n                // Matches object-style strings: directive[expression](...values)\n                values = getMatchInBetween(command, '](', ')');\n                breakDownId = getMatchInBetween(command, '[', ']');\n                directive = command.split('[')[0].trim();\n            } else {\n                // Matches object-style strings: directive.tablet(...values)\n                values = getMatchInBetween(command, '(', ')');\n                command = command.replace(getMatchBlock(command, '(', ')'), '');\n                [directive, breakDownId] = getChunks(command, '.');\n            }\n\n            values = getArrObjFromString(values);\n\n            if (!setObject[directive]) setObject[directive] = {};\n\n            getChunks(breakDownId, '|').forEach((id) => {\n                setObject[directive][id] = values;\n            });\n        });\n\n        return results('dotObject', setObject);\n    }\n}\n\n/**\n * Find math by delimeters returns raw matches\n * @function getMatchBlock\n * @param {String} str\n * @param {String|Regex} p1\n * @param {String|Regex} p2\n * @param {Boolean} all If it should return all matches or single one (default)\n * @return {String|Array|Null}\n * @example getMatchBlock('is a hello world today', 'h', 'd') // 'hello world'\n * @example getMatchBlock('is a hello world today', 'h', 'd', true) // ['hello world']\n * @example getMatchBlock('is a <hello world/> today', '<', '/>') // '<hello world/>'\n */\nfunction getMatchBlock(str, p1, p2, all = false) {\n    if (typeof str !== 'string') return str;\n    p1 = setExpString(p1);\n    p2 = setExpString(p2);\n    let regex = new RegExp(setLookUpExp(p1, p2), 'gm');\n    const matches = str.match(regex);\n    if (matches) {\n        return all ? matches : matches[0];\n    }\n    return null;\n}\n/**\n * Splits a string into chunks by a given splitter and cleans the chunks\n * @param {string} str\n * @param {string} splitter - The string/character to split the string by. Defaults to ','\n * @return {string|array}\n */\nfunction getChunks(str, splitter = ',') {\n    if (typeof str !== 'string') return str;\n    if ((0,_Utility__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(str)) return [];\n    str = cleanStr(str);\n    let chunks = str.split(splitter).map((t) => cleanStr(t));\n    return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;\n}\n\n/**\n * find a match in between two delimeters, either string or regex given, returns clean matches\n * @function getMatchBlock\n * @param {String} str\n * @param {String|Regex} p1\n * @param {String|Regex} p2\n * @param {Boolean} all If it should return all matches or single one (default)\n * @return {String|Array|Null}\n * @example getMatchInBetween('hello world', 'h', 'd') // 'ello worl'\n * @example getMatchInBetween('hello <world/>', '<', '/>', true) // ['world']\n * @example getMatchInBetween('hello <world/>', '<', '/>') // 'world'\n */\nfunction getMatchInBetween(str, p1, p2, all = false) {\n    if (typeof str !== 'string') return str;\n    const matchBlock = getMatchBlock(str, p1, p2, all) ?? (all ? [] : str);\n    return all ? matchBlock.map((match) => cleanStr(match, p1, p2)) : cleanStr(matchBlock, p1, p2);\n}\n\n/**\n * Remove quotes from a string\n * @function removeQuotes\n * @param {String} str\n * @return {String}\n * @example removeQuotes('\"hello\"') // hello\n * @example removeQuotes(\"'hello'\") // hello\n */\nfunction removeQuotes(str) {\n    if (typeof str !== 'string') return str;\n    return str.replace(/\\`|'|\"/g, '');\n}\n\n/**\n * Checks if a string starts and ends with a given string\n * @param {string} strExp\n * @param {string} start - The string/character to check it starts with\n * @param {string} end - The string/character to check it ends with\n * @return {string}\n * @example startAndEndWith('hello world', 'h', 'd') // false\n * @example startAndEndWith('hello world', 'h', 'd') // true\n */\nfunction startAndEndWith(strExp, start = null, end = null) {\n    return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));\n}\n\n/**\n * Scapes a string to create a regex or returns the regex if it already is an expression\n * @function setExpString\n * @param {String|Regex} exp\n * @return {String|Regex}\n * @example setExpString('hello') // '\\h\\e\\l\\l\\o'\n * @example setExpString(/hello/) // /hello/\n * @example setExpString([hello]) // \\\\[hello\\\\/ then use like new new RegExp(setExpString(StringOrRegex))\n */\nfunction setExpString(exp) {\n    if (exp instanceof RegExp) {\n        return exp;\n    } else {\n        return exp\n            .split('')\n            .map((char) =>\n                ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\\\'].includes(char)\n                    ? `\\\\${char}`\n                    : char,\n            )\n            .join('');\n    }\n}\n\n/**\n * Regex builder to get a match in between two delimeters\n * @function setLookUpExp\n * @param {String|Regex} args - minimun two arguments as delimeters\n * @return {String} - Regex\n * @example setLookUpExp('h', 'd') // 'h((.|\\n)*?)d'\n * @example setLookUpExp('h', 'd', 'c') // 'h((.|\\n)*?)d((.|\\n)*?)c'\n * @usage:\n * const pattern = setLookUpExp(\".\", \"!\");\nconst regex = new RegExp(pattern, 'g');\nconst text = \"Hello World. Sunshine is here! Have fun!\";\nconst matches = text.match(regex);\nconsole.log(matches);  // Output: [\". Sunshine is here!\"]\n */\nfunction setLookUpExp(...args) {\n    if (args.length < 2) {\n        throw new Error('You need to pass at least two arguments');\n    }\n    let expression = '';\n    // loop through args\n    args.forEach((arg, index) => {\n        // if arg is a regex, return the source\n        if (arg instanceof RegExp) {\n            arg = arg.source;\n        }\n        if (index === 0) {\n            expression = arg;\n        } else {\n            expression += `((.|\\n)*?)${arg}`;\n        }\n    });\n\n    return expression;\n}\n\n/**\n * Set a string to be used as a wildcard pattern\n * @function setWildCardString\n * @param {string} string - The string to set as a wildcard pattern\n * @param {boolean} matchStart - If the pattern should match the start of the string\n * @param {boolean} matchEnd - If the pattern should match the end of the string\n * @return {string} - The wildcard pattern\n * @example setWildCardString('name.*', true) // returns '^name\\.(.*?)'\n * @example setWildCardString('name.*', false, true) // returns 'name\\.(.*?)$'\n * @example setWildCardString('name.**') // returns 'name\\..*' greedy\n */\nfunction setWildCardString(str, matchStart = false, matchEnd = false) {\n    if (typeof str !== 'string') return str;\n    if (!str) {\n        return null;\n    }\n    matchStart = (0,_Utility__WEBPACK_IMPORTED_MODULE_0__.convertToBool)(matchStart);\n    matchEnd = (0,_Utility__WEBPACK_IMPORTED_MODULE_0__.convertToBool)(matchEnd);\n    let regexStr = str.replace(/([.+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$&'); // escape all regex special chars\n    let regStart = matchStart ? '^' : '';\n    let regEnd = matchEnd ? '$' : '';\n\n    regexStr = regexStr\n        .replace(/\\*\\*/g, '[_g_]') // Replace wildcard patterns with temporary markers\n        .replace(/\\*/g, '(.*?)')\n        .replace(/\\[_g_\\]/g, '.*');\n\n    return `${regStart}${regexStr}${regEnd}`;\n}\n\n/**\n * Search for a wildcard pattern in a list of strings or viceversa\n * @method wildCardStringSearch\n * @param {string} pattern - The pattern to search for\n * @param {array|string} list - The list of strings to search in\n * @param {boolean} matchStart - If the pattern should match the start of the string (optional)\n * @param {boolean} matchEnd - If the pattern should match the end of the string optional)\n * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found\n * @example wildCardStringSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']\n */\nfunction wildCardStringSearch(pattern, listOrString, matchStart = false, matchEnd = false) {\n    if (!pattern || !listOrString) {\n        return null;\n    }\n\n    const regex = new RegExp(setWildCardString(pattern, matchStart, matchEnd));\n\n    if (typeof listOrString === 'string') {\n        const matches = listOrString.match(regex);\n        return (0,_Utility__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(matches);\n    }\n\n    let filteredList = [];\n    filteredList = listOrString.filter((item) => regex.test(item));\n\n    return (0,_Utility__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(filteredList);\n}\n\nconst powerHelper = {\n    addQuotes,\n    cleanStr,\n    convertKeysToSymbols,\n    findAndReplaceInArray,\n    findNested,\n    fixQuotes,\n    getArrObjFromString,\n    getChunks,\n    getDirectivesFromString,\n    getMatchBlock,\n    getMatchInBetween,\n    removeQuotes,\n    startAndEndWith,\n    setExpString,\n    setLookUpExp,\n    setWildCardString,\n    wildCardStringSearch,\n};\n\n// Export ES6 modules\n\n\n\n//# sourceURL=webpack://PowerHelpers/./src/PowerHelpers.js?");

/***/ }),

/***/ "./src/ProxyHelper.js":
/*!****************************!*\
  !*** ./src/ProxyHelper.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ProxyHelper)\n/* harmony export */ });\n/* Author Knighttower\n    MIT License\n    [2023] [Knighttower] https://github.com/knighttower\n*/\n/**\n * @module ProxyHelper\n * Convert to proxy to protect objects\n * Allows to declare _private, _protected and _mutable - all arrays with prop names\n * @example ProxyHelper({objectProps..., _protected: array(...)})\n * @param {Object} object\n * @return {Proxy}\n * @usage const proxy = ProxyHelper({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})\n * @usage _protected: array(...) -> Cannot be modified\n * @usage _private: array(...) -> Cannot be accessed\n * @usage _mutable: array(...) -> Can be modified\n */\nfunction ProxyHelper(object) {\n    'use strict';\n    const _private = new Map((object._private || ['_private']).map((prop) => [prop, true]));\n    const _protected = new Map([..._private, ...(object._protected || []).map((prop) => [prop, true])]);\n    const _mutable = new Map((object._mutable || []).map((prop) => [prop, true]));\n\n    return new Proxy(object, {\n        get(target, prop) {\n            if (prop in target && !_private.has(String(prop))) {\n                return target[prop];\n            } else {\n                console.error('Prop is private, not set, or object is protected', prop);\n                return undefined;\n            }\n        },\n        set(target, prop, value) {\n            prop = String(prop);\n            if (prop in target) {\n                if (_mutable.has(prop)) {\n                    target[prop] = value;\n                    return true;\n                }\n                if (!_protected.has(prop) && !_private.has(prop)) {\n                    target[prop] = value;\n                    return true;\n                } else {\n                    console.error('The prop is protected or private and cannot be modified', prop, value);\n                    return false;\n                }\n            } else {\n                console.error('Protected Object, cannot set new props', prop, value);\n                return false;\n            }\n        },\n    });\n}\n\n\n//# sourceURL=webpack://PowerHelpers/./src/ProxyHelper.js?");

/***/ }),

/***/ "./src/Utility.js":
/*!************************!*\
  !*** ./src/Utility.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utility: () => (/* binding */ Utility),\n/* harmony export */   convertToBool: () => (/* binding */ convertToBool),\n/* harmony export */   convertToNumber: () => (/* binding */ convertToNumber),\n/* harmony export */   currencyToDecimal: () => (/* binding */ currencyToDecimal),\n/* harmony export */   dateFormat: () => (/* binding */ dateFormat),\n/* harmony export */   decimalToCurrency: () => (/* binding */ decimalToCurrency),\n/* harmony export */   \"default\": () => (/* binding */ Utility),\n/* harmony export */   emptyOrValue: () => (/* binding */ emptyOrValue),\n/* harmony export */   formatPhoneNumber: () => (/* binding */ formatPhoneNumber),\n/* harmony export */   getDynamicId: () => (/* binding */ getDynamicId),\n/* harmony export */   getGoogleMapsAddress: () => (/* binding */ getGoogleMapsAddress),\n/* harmony export */   getRandomId: () => (/* binding */ getRandomId),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instanceOf: () => (/* binding */ instanceOf),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   openGoogleMapsAddress: () => (/* binding */ openGoogleMapsAddress),\n/* harmony export */   proxyObject: () => (/* binding */ proxyObject),\n/* harmony export */   selectElement: () => (/* binding */ selectElement),\n/* harmony export */   toCurrency: () => (/* binding */ toCurrency),\n/* harmony export */   toDollarString: () => (/* binding */ toDollarString),\n/* harmony export */   typeOf: () => (/* binding */ typeOf),\n/* harmony export */   utility: () => (/* binding */ Utility),\n/* harmony export */   utils: () => (/* binding */ Utility),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail),\n/* harmony export */   validatePhone: () => (/* binding */ validatePhone)\n/* harmony export */ });\n/* harmony import */ var _ProxyHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ProxyHelper */ \"./src/ProxyHelper.js\");\n/* harmony import */ var _ElementHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ElementHelper */ \"./src/ElementHelper.js\");\n// // -----------------------------------------\n// /**\n//  * @knighttower\n//  * @url knighttower.io\n//  * @git https://github.com/knighttower/\n//  * @license MIT\n//  */\n// // -----------------------------------------\n\n// @see https://github.com/knighttower/JsObjectProxyHelper\n\n\n// @see https://github.com/knighttower/ElementHelper\n\n\n// -----------------------------\n// METHODS\n// -----------------------------\n\n/**\n * Convert a value to bool\n * @param {String|Boolean|Int|Number} val\n * @return {Boolean}\n * @usage convertToBool('true') // true\n * @usage convertToBool('false') // false\n * @usage convertToBool('0') // false\n * @usage convertToBool('1') // true\n * @usage convertToBool('') // false\n * @usage convertToBool('true') // true\n * @usage convertToBool('false') // false\n */\nfunction convertToBool(val) {\n    switch (typeof val) {\n        case 'boolean':\n            return val;\n        case 'string':\n            return val === 'false' || val === '0' ? false : true;\n        case 'number':\n            return val !== 0;\n        default:\n            return Boolean(val);\n    }\n}\n\n/**\n * Converts a given variable to a number if possible.\n * @param {string|number} input - The input variable to convert.\n * @returns {string|number} - The converted number or the original variable.\n * @example convertToNumber(123) // Output: 123 (number)\n * @example convertToNumber(123.45) // Output: 123.45 (number)\n * @example convertToNumber(\"123\") // Output: 123 (number)\n * @example convertToNumber(\"123.45\") // Output: 123.45 (number)\n * @example convertToNumber(\"abc\") // Output: \"abc\" (original string)\n * @example convertToNumber(\"123abc\") // Output: \"123abc\" (original string)\n * @example convertToNumber(null) // Output: null (original)\n */\nfunction convertToNumber(input) {\n    const isNum = isNumber(input);\n\n    if (isNum !== null) {\n        return isNum;\n    }\n    // Case: String that cannot be converted to a number\n    return input;\n}\n\n/**\n * Translate dollar amounts to decimal notation\n * @function currencyToDecimal\n * @memberof Utility\n * @param {String|Number} amount\n * @return number\n * @example currencyToDecimal('$123.45') // 123.45\n */\nfunction currencyToDecimal(amount) {\n    return Number(amount.replace(/[^0-9.-]+/g, ''));\n}\n\n/**\n * Format dates to standard US, with or w/out time\n * @function dateFormat\n * @memberof Utility\n * @param {String} dateTime Raw format 2201-01-01 16:15PM or unix or object\n * @param {Boolean} wTime If set, returns date with time as H:MM A\n * @return string\n * @example dateFormat('2201-01-01 16:15PM') // 01/01/2201\n * @example dateFormat('2201-01-01 16:15PM', true) // 01/01/2201 @ 4:15 PM\n * @example dateFormat('2201-01-01 16:15PM', false) // 01/01/2201\n * @example dateFormat('2201-01-01') // 01/01/2201\n */\nfunction dateFormat(dateTime, wTime) {\n    if (!dateTime || isNaN(new Date(dateTime).getTime())) {\n        return null;\n    }\n\n    const date = new Date(dateTime);\n\n    // Ensuring that the time zone is taken into account.\n    const optionsDate = { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'UTC' };\n    const formattedDate = new Intl.DateTimeFormat('en-US', optionsDate).format(date);\n\n    if (wTime) {\n        const optionsTime = { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' };\n        const formattedTime = new Intl.DateTimeFormat('en-US', optionsTime).format(date);\n        return `${formattedDate} @ ${formattedTime}`;\n    }\n\n    return formattedDate;\n}\n\n/**\n * Translate decimal notation to dollar amount\n * @function decimalToCurrency\n * @memberof Utility\n * @param {String|Number} amount\n * @return number\n * @example decimalToCurrency(123.45) // 123.45\n * @example decimalToCurrency(2123.46) // 2,123.46\n */\nfunction decimalToCurrency(amount) {\n    const formatConfig = {\n        minimumFractionDigits: 2,\n    };\n    return new Intl.NumberFormat('en-GB', formatConfig).format(amount);\n}\n\n/**\n * Check if there is a value, if not return null or the default value\n * It can test strings, arrays, objects, numbers, booleans\n * @function emptyOrValue\n * @memberof Utility\n * @param {String|Number} value If the value is not empty, returns it\n * @param {String|Number} _default The default value if empty\n * @return mixed\n * @example emptyOrValue('test', 'default') // 'test'\n * @example emptyOrValue('', 'default') // 'default'\n * @example emptyOrValue('test') // 'test'\n * @example emptyOrValue('') // null\n * @example emptyOrValue(0) // 0\n * @example var hello = ''; emptyOrValue(hello) // Null\n * @example var hello = 'test'; emptyOrValue(hello) // 'test'\n * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'\n * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'\n * @example var hello = []; emptyOrValue(hello, 'default') // null\n * @example var hello = {}; emptyOrValue(hello, 'default') // null\n * @example var hello = [...]; emptyOrValue(hello') // [...]\n */\nfunction emptyOrValue(value, _default = null) {\n    /**\n     * Test sequence:\n     * If it is a number 0> : true\n     * If is not undefined: true\n     * If it is boolean (true|false) prevents going to empty\n     * If it is not Empty, [], null, {}, 0, true, false: true\n     */\n\n    if (isNumber(value) !== null || typeof value === 'boolean') {\n        return value;\n    } else if (!isEmpty(value)) {\n        return value;\n    }\n\n    return _default;\n}\n\n/**\n * Format a phone number based on a given template.\n * @param {string} phoneNumber - The phone number to format.\n * @param {string} template - The template to use for formatting.\n * @returns {string} - The formatted phone number.\n * @example console.log(formatPhoneNumber('1234567890', '(000) 000-0000')); // Output: (123) 456-7890\n * @example console.log(formatPhoneNumber('1234567890', '000-000-0000')); // Output: 123-456-7890\n * @example console.log(formatPhoneNumber('123-456-7890', '(000) 000-0000')); // Output: (123) 456-7890\n * @example console.log(formatPhoneNumber('(123) 456-7890', '000-0000-0000')); // Output: 123-4567-890\n */\nfunction formatPhoneNumber(phoneNumber, template) {\n    // Remove all non-numeric characters from the phone number\n    const cleaned = phoneNumber.replace(/\\D/g, '');\n\n    // Verify the length of the cleaned phone number\n    if (cleaned.length !== 10) {\n        throw new Error('Invalid phone number length');\n    }\n\n    // Initialize an array to hold the formatted phone number\n    let formatted = [];\n\n    // Initialize a pointer for the cleaned phone number\n    let cleanedPointer = 0;\n\n    // Loop through the template and replace placeholders with actual numbers\n    for (let i = 0; i < template.length; i++) {\n        if (template[i] === '0') {\n            formatted.push(cleaned[cleanedPointer]);\n            cleanedPointer++;\n        } else {\n            formatted.push(template[i]);\n        }\n    }\n\n    return formatted.join('');\n}\n\n/**\n * Generate unique ids\n * @function getDynamicId\n * @memberof Utility\n * @return string Format kn__000000__000\n */\nfunction getDynamicId() {\n    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));\n}\n\n/**\n * Alias to getDynamicId\n * @function getRandomId\n * @memberof Utility\n * @return string\n * @example getRandomId() // kn__000000__000\n */\nconst getRandomId = getDynamicId;\n\n/**\n * Form a valid Google search address\n * @function getGoogleMapsAddress\n * @memberof Utility\n * @param {String|Object} address\n * @return string\n * @example getGoogleMapsAddress('New York') // 'https://maps.google.it/maps?q=New+York'\n * @example getGoogleMapsAddress({ address: 'New York', zip: '10001' }) // 'https://maps.google.it/maps?q=New+York+10001'\n * @example getGoogleMapsAddress({ address: 'New York', city: 'New York', state: 'NY' }) // 'https://maps.google.it/maps?q=New+York+New+York+NY'\n */\nfunction getGoogleMapsAddress(address) {\n    if (!address) return false;\n\n    let search = '';\n\n    if (typeOf(address, 'string')) {\n        search = address;\n    } else {\n        const keys = ['address', 'address1', 'city', 'state', 'zip', 'zipcode'];\n\n        search = keys.reduce((acc, key) => {\n            const value = Object.keys(address).find((aKey) => aKey.includes(key) && address[aKey]);\n            return value ? `${acc} ${address[value]}` : acc;\n        }, '');\n    }\n\n    search = search.trim().replace(/\\s+|,/g, '+');\n    return `https://maps.google.it/maps?q=${search}`;\n}\n\n/**\n * Check if a value is in a collection (array, string, object)\n * @param {collection} collection - The collection to search in\n * @param {value} value - The value to search for\n * @param {fromIndex} fromIndex - The index to start searching from\n * @return {boolean} - True if the value is in the collection, false otherwise\n */\nfunction includes(collection, value, fromIndex = 0) {\n    if (Array.isArray(collection) || typeof collection === 'string') {\n        // Use native includes for arrays and strings\n        return collection.includes(value, fromIndex);\n    }\n\n    if (typeof collection === 'object') {\n        // Search in object values\n        for (let key in collection) {\n            if (collection[key] === value) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Check if a value is empty\n * @function isEmpty\n * @memberof Utility\n * @param {string|array|object|map|set|number|boolean} value\n * @url https://moderndash.io/\n * @return {string}\n */\nfunction isEmpty(value) {\n    if (value === null || value === undefined) return true;\n\n    if (typeof value === 'string' || Array.isArray(value)) return value.length === 0;\n\n    if (value instanceof Map || value instanceof Set) return value.size === 0;\n\n    if (ArrayBuffer.isView(value)) return value.byteLength === 0;\n\n    if (typeof value === 'object') return Object.keys(value).length === 0;\n\n    return false;\n}\n\n/**\n * Check if is a number or Int, if not return null\n * Integrates both Int and Number, or convert a string number to number to test\n * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'\n * @function isNumber\n * @memberof Utility\n * @param {String|Number} value\n * @return null|int\n * @example isNumber(123) // true\n * @example isNumber(123.45) // true\n * @example isNumber('123abc') // false\n * @example isNumber('abc') // false\n * @example isNumber('') // false\n * @example isNumber(\"123\") // true\n * @example isNumber(\"123.45\") // true\n */\nfunction isNumber(value) {\n    const isType = typeof value;\n    switch (value) {\n        case null:\n        case undefined:\n        case '':\n            return null;\n        case '0':\n        case 0:\n            return 0;\n        default:\n            if (isType === 'number' || isType === 'string') {\n                if (typeof value === 'number' || !Number.isNaN(Number(value))) {\n                    return +value;\n                }\n            }\n\n            break;\n    }\n\n    return null;\n}\n\n/**\n * Check the instance of a variable, and get the correct type for it. It also accepts simple comparisons\n * For more advance type checking see https://github.com/knighttower/JsTypeCheck\n * @param {any} input - The variable to check\n * @return {string|boolean} - The type of the variable or boolean when test is provided\n */\nfunction instanceOf(input, test) {\n    let inputType = 'unknown';\n    if (input === null) {\n        return inputType;\n    }\n    const instanceMapping = [\n        {\n            type: 'date',\n            inst: Date,\n        },\n        {\n            type: 'regexp',\n            inst: RegExp,\n        },\n        {\n            type: 'promise',\n            inst: Promise,\n        },\n        {\n            type: 'map',\n            inst: Map,\n        },\n        {\n            type: 'set',\n            inst: Set,\n        },\n        {\n            type: 'weakMap',\n            inst: WeakMap,\n        },\n        {\n            type: 'weakSet',\n            inst: WeakSet,\n        },\n    ];\n    let instTotal = instanceMapping.length;\n    while (instTotal--) {\n        if (input instanceof instanceMapping[instTotal].inst) {\n            inputType = instanceMapping[instTotal].type;\n            break;\n        }\n    }\n\n    if (test) {\n        return test === inputType;\n    }\n\n    return inputType;\n}\n\n/**\n * Open a Google Map using a provided address\n * @function openGoogleMapsAddress\n * @memberof Utility\n * @param {String|Object} object - Address information either as a string or as an object\n * @throws {Error} Throws an error if the address is invalid or if it's not a string or object.\n * @return {void}\n * @example openGoogleMapsAddress('New York'); // Opens Google Maps with the address 'New York'\n * @example openGoogleMapsAddress({ address: 'New York', zip: '10001' }); // Opens Google Maps with the address 'New York 10001'\n */\nfunction openGoogleMapsAddress(object) {\n    if (!typeOf(object, 'string') || !typeOf(object, 'object')) {\n        throw new Error('The input must be a string or an object.');\n    }\n\n    const address = getGoogleMapsAddress(object);\n\n    if (!isEmpty(address) || !typeOf(address, 'string')) {\n        throw new Error('The address you are trying to open is invalid.');\n    }\n\n    return window.open(address, '_blank');\n}\n\n/**\n * @example ProxyHelper({objectProps..., _protected: array(...)})\n * @param {Object} object\n * @return {Proxy}\n * @usage const proxy = ProxyHelper({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})\n * @usage _protected: array(...) -> Cannot be modified\n * @usage _private: array(...) -> Cannot be accessed\n * @usage _mutable: array(...) -> Can be modified\n */\nfunction proxyObject(obj) {\n    return (0,_ProxyHelper__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(obj);\n}\n\n/**\n * Dom Element selector\n * @function selectElement\n * @param {String} selector - The selector to search for\n * @param {Object} scope - The scope to search in\n * @return {String} - The first element that matches the selector\n * @uses ElementHelper @knighttower/element-helper (https://github.com/knighttower/ElementHelper)\n * @example selectElement('#test') // <div id=\"test\"></div>\n */\nfunction selectElement(selector, scope = document) {\n    return new _ElementHelper__WEBPACK_IMPORTED_MODULE_1__[\"default\"](selector, scope);\n}\n\n/**\n * Alias to getDynamicId\n * @function toCurrency\n * @memberof Utility\n * @param {String|Number} amount\n * @return number\n * @example toCurrency(123.45) // 123.45\n * @example toCurrency(2123.46) // 2,123.46\n */\nfunction toCurrency(amount) {\n    return decimalToCurrency(amount);\n}\n\n/**\n * Covert to dollar string\n * @function toDollarString\n * @memberof Utility\n * @param {String|Number} amount\n * @return number\n * @example toDollarString(2,000) // 2K\n * @example toDollarString(2,000,000) // 2M\n * @example toDollarString(2,500,000) // 2.5M\n */\nfunction toDollarString(amount) {\n    if (typeOf(amount, 'string')) {\n        amount = currencyToDecimal(amount);\n    }\n\n    if (Math.abs(amount) > 999 && Math.abs(amount) < 999999) {\n        return Math.sign(amount) * (Math.abs(amount) / 1000).toFixed(1) + 'K';\n    }\n    if (Math.abs(amount) > 999999) {\n        return Math.sign(amount) * (Math.abs(amount) / 1000000).toFixed(1) + 'M';\n    }\n\n    return Math.sign(amount) * Math.abs(amount);\n}\n\n/**\n * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons\n * For more advance type checking see https://github.com/knighttower/JsTypeCheck\n * @param {any} input - The variable to check\n * @param {string} test - The types to check against, piped string\n * @return {string|boolean} - The type of the variable\n * @example typeOf('hello', 'string') // returns true\n * @example typeOf('hello', 'number') // returns false\n * @example typeOf('hello', 'string') // returns true\n * @example typeOf('hello') // returns 'string'\n * @example typeOf({}) // returns 'object'\n */\nfunction typeOf(input, test) {\n    // Special case for null since it can be treated as an object\n    if (input === null) {\n        if (test) {\n            return test === null || test === 'null' ? true : false;\n        }\n        return 'null';\n    }\n\n    let inputType;\n\n    switch (typeof input) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'undefined':\n        case 'bigint':\n        case 'symbol':\n        case 'function':\n            inputType = typeof input;\n            break;\n        case 'object':\n            inputType = Array.isArray(input) ? 'array' : 'object';\n\n            break;\n        default:\n            inputType = 'unknown';\n    }\n\n    if (test) {\n        return test === inputType;\n    }\n\n    return inputType;\n}\n\n/**\n * Validate emails\n * @function validateEmail\n * @memberof Utility\n * @param {String} email\n * @return Boolean\n * @example validateEmail('<EMAIL>') // false\n * @example validateEmail('test@test') // false\n * @example validateEmail('test@test.') // false\n * @example validateEmail('test@test.c') // false\n * @example validateEmail('test@test.com') // true\n */\nfunction validateEmail(email) {\n    var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$/;\n    return emailRegex.test(email);\n}\n\n/**\n * Validate a phone number\n * @function validatePhone\n * @memberof Utility\n * @param {String} phone\n * @return void|Toast\n * @example validatePhone('1234567890') // true\n * @example validatePhone('(123) 456-7890') // true\n * @example validatePhone('123-456-7890') // true\n * @example validatePhone('123 456 7890') // false\n * @example validatePhone('123-4567-89') // false\n */\nfunction validatePhone(phone) {\n    var phoneRegex = /^\\(?(\\d{3})\\)?[- ]?(\\d{3})[- ]?(\\d{4})$/;\n    return phoneRegex.test(phone);\n}\n\n// export default Utility;\nconst Utility = {\n    convertToBool,\n    currencyToDecimal,\n    convertToNumber,\n    dateFormat,\n    decimalToCurrency,\n    emptyOrValue,\n    formatPhoneNumber,\n    getDynamicId,\n    getGoogleMapsAddress,\n    getRandomId,\n    includes,\n    isEmpty, // from https://moderndash.io/\n    isNumber,\n    instanceOf,\n    openGoogleMapsAddress,\n    proxyObject,\n    selectElement,\n    toCurrency,\n    toDollarString,\n    typeOf,\n    validateEmail,\n    validatePhone,\n};\n\n// Export ES6 modules\n\n\n\n//# sourceURL=webpack://PowerHelpers/./src/Utility.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/PowerHelpers.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});